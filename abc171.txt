E - Red Scarf
	https://atcoder.jp/contests/abc171/tasks/abc171_e
	N匹のすぬけくん
	番号を振られている
		自分以外のすぬけくんのスカーフに書かれた整数のxorを計算する
	番号iが振られたすぬけくんが計算した自分以外のすぬけくんのスカーフに書かれた整数のxorがai
	各すぬけくんのスカーフに書かれた整数を特定せよ
		a0 xor a1 xor a2 xor a3 xor
		偶数である事を考える？
			すると自分の数字は奇数回xorされる
			つまり残る
				となると全ての数字をxorすると全部のxorされた値が求められる

F - Strivore
	https://atcoder.jp/contests/abc171/tasks/abc171_f
	好きな英小文字1文字を好きな位置に挿入する
		という操作を文字列sにk回繰り返して出来る文字列は何通りあるか？
	1<=k<=10^6
	1<=s<=10^6
	英小文字なので26通り
		最終なので入れた順番は無関係
	同じ文字列になる場合の数が存在する
		abがあった場合に
		k=2として
			ab(ab)
			(ab)ab
			と挿入される場合である
		文字列が大きいのでDPも難しい？
			26文字と考えて何とか行けないだろうか？
		頭から処理するとして
			すでに頭から何文字目まで使われたか？
				というdpを考えると
					頭から何文字目か？
						という数字がどうしても1000000まで必要となる
							なおkも1000000なので、厳しいだろう
			例えばaが10^6個つながっていたとして
				初めてaが出てきた場合、次のaが出てきた場合と処理していくと
					えげつない量のメモリと計算量が必要となる
		上のab(ab)は
			先に出てきた場合だけを考えたい
		oofも
			oo(oo)fとなった時先に出てきたという事にしたい
		各パターンに関して計算するのも大きくなりすぎてダメだろう
	n+kCnで固定する場所を取得する
	やはりこれも前後ろの割り算が必要になるが出来ない
		前からDPに方が筋が良さそうには思えるが。。。
	kだけで考える？
		k文字で自由に作った文字列にsを入れる作業であるとも言い換えられる
	どのような視点が足りていない？
		上のkだけで考えるは考慮しきれた？
	getpow(26,k)で全パターンが求められる
		それでダブルカウントを取り除かなければならない
			sと同じ文字というだけでは足りず
				sの任意の文字siに対してその前後にsiと同じ文字が含まれているような場合を割らなければ行けないわけだ
	ある文字siの前には同じ文字siは入れられないという考え方
		つまりabのs0の前にaは入れられないので25通り
		aの後ろにはなんでも入れられると思いきや、bは入れられないのでやはり25通り
		一番後ろには好きな文字を入れられる
			あれ？
			これで行ける？
				つまり一番後ろに何文字置くかで場合分け
		後ろi個で重複する？

			
			
			

		