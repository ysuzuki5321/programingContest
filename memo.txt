E - Change a Little Bit
	https://atcoder.jp/contests/abc150/tasks/abc150_e
	0,1からなる長さNの異なる２つの数列S,T
		関数f(S,T)を以下のように定める
			SをTに変換する
				一つのiを変換するとき
					異なっている要素数をdとする
						ci*dがそのiの変換コストとなる
		f(S,T)の和を10^9+7で割った余りを計算する
	あるiが異なっている時、それが残りいくつの時に変換されるかを考える
		Ciをソートし、小さい順に考える
			Ci=a,Ci+1=bとしたとき
				a<=b
			異なっている要素数をdとすると
				d>d-1
			a*d+b*(d-1)と
			a*(d-1)+b*dのどちらが大きいかを考える
				ad+bd-b
				ad+bd-a
				となり
					ad+bd-b<=ad+bd-aである
		となるのでaの方が先に処理される
	例えばc1はあらゆるパターンで最初に処理される
	要素数をxとすると
		x個異なっているのは2パターン
		x-1個異なっているのは2*xC1パターン
			その中に自分が含まれているのは2*(x-1)C1
		x-2個異なっているは2*xC2パターン
			その中に自分が含まれているのは2*(x-1)C2
			,,,,,,
		自分より右側のあらゆるパターンにより加算される
			左側は各パターンに掛け算される
			2^pで表現できるか？
		異なっている場所を1で表現し要素3で考えると
			100
			010
			001
			110
			101
			011
			111
			12である
				3+6+3
			要素数2になると
			10
			01
			11
			2+2
			で4である
			要素数1は1
			要素数4は？
				1000
				0100
				0010
				0001
				1100
				1010
				1001
				0110
				0101
				0011
				1110
				1101
				1011
				0111
				1111
				4+12+12+4=32
					2項係数っぽい
			漸化式に出来そう
				1の時は1
				2の時は
					前の1をそのまま使用する
					前の1を使用して自分も足す
					前の1を使用しない
					パターン数3
				3の時は
					2をそのまま使用する = 4
					2を使用して自分を足す = 3+4
					2を使用しない = 1
					パターン数3+3+1=7
					総和12
				4の時は
					1.12
					2.12+7
					3.1
					p=7+7+1=15
				,,,,,,
				で組み立てられる
					パターン数と総和をそれぞれ配列で保持する
			AC!!!!!!!!

F - Small Products
	https://atcoder.jp/contests/abc132/tasks/abc132_f
	整数k個
	隣接して並んでいるどの二つの数の積もN以下であるものの個数を10^9+7で割った余りで求めよ
	1<=k<=100
	1<=n<=10^9
		隣り合っている数がどのような状態になるかを考える必要がある
			例えばn=6の時
				1 1
				1 2
				1 3
				1 4
				1 5
				1 6
				2 1
				2 2
				2 3
				3 1
				3 2
				4 1
				5 1
				6 1
			しかしさらに隣が加わると
				dpで畳み込みたくなる
					が、nが巨大
						これをどう処理するか
							sqrtまで処理出来れば行けるようにならないか？
			約数でも良さそう
				例えばn>=x>n/2なるxは全て1にならないといけない
					n/2>=x>n/3なるxは全て1か2にならないといけない
					という風に上から下への計算は出来る
					1はnまでの数全てになれる
					同じ形がひたすら続くので３つ目までカウント出来ればあとは式に出来るはず
						1 (1~6)
						2 (1~3)
						3 (1~2)
						4 1
						5 1
						6 1
					これをグループに分ける
						1        ,2 ,3 ,(4,5,6)
						/(4,5,6) /3 /2 /1
						1 6
						2 3
						3 2
						(4,5,6) 1*3
					もう少し数が大きいと分かりやすそう
					とりあえずn=6で3つめは
						1 6 から 6つずつ全てのグループに入る
						2 3 から 3つずつ1,2,3のグループに入る
						3 2 から 2つずつ1,2のグループに入る
						(4,5,6)から 1*3ずつ1のグループに入る
						o(k√nlog√n)
					グループの分割方法
						n=7の時
						1 (4,5,6,7)
						2 3
						3 2
						(4,5,6,7) 1
						n=10の時
						1 (6,7,8,9,10)
						2 (4,5)
						3 3
						(4,5) 2
						(6,7,8,9,10) 1
						半分になる
					しかもこれは約数ではない
						sqrt(n)をまたいで二つに分かれそう
						n=10
						g1 : 1
						g2 : 1
						g3 : 1
						g4 : 2
						g5 : 5
						10/1=10
						10/2=5
						10/3=3
						10/4=2
						10/5=2
						10/6=1
						10/7=1
						10/8=1
						10/9=1
						10/10=1

D - Worst Case
	https://atcoder.jp/contests/abc093/tasks/arc094_b
	一度解いているらしいが2月にやった時は完全に忘れていて解けなかったまま放置されてた
	2回のコンテストでAi位、２回目のコンテストでBi位である
	スコアは順位を掛け合わせた数
		1<=ai<=10^9 1<=bi<=10^9なので最大でも10^18
	これは2分探索で行けるのではなかろうか？
		掛け合わせた値より下のスコアの者たちはどれくらいおるかである
			小さい数字で考えるべき
				5位7位を取ったとするとスコアは35である
				これより小さい数の組み合わせで最大を取ろうとすると
					1位に対して34が割り当てられ
					2位に対して17が割り当てられ
					3位に対して34/3の11が割り当てられ
					4位に対して34/4の8が割り当てられ
					同様に
					5,7
					6,5
					7,4
					8,3
					9,2
					10,1
					となり10人が取れるが、自分の順位は省かれるため
					9となる予感
					3,3で4となっている
					1,8
					2,4
					4,2
					5,1で4だろう
					4,11で11である
					最大は44
					1,43
					2,21
					3,14
					5,8
					6,7
					7,6
					8,5
					9,4
					10,3
					11,2
					12,1
					である
					片側でどこまで取れるかで完成できる
						まず大小を入れ替える
							a>bとなっている場合、交換する
							組み合わせにおいてa'*b'かつa'>b'でa'-b'が一番小さいところを考える
							√(score-1)=tが近い
								t*t=score-1であるかどうか
					43以下の数字についてみる
						7*6=42でまたいで6要素は可となる
						√43=6となる
						6*6と7*6を比較する
							これは二つ離れられない？
								score-1とscoreは1しか変わらない
									つまり平方数はほぼ同じはずである
							144=12*12
							11*13=143となる
							143はsqrt(143)を計算すると11になってしまい
							2つ離れる
								しかし、11は決定する
									というか12*11で良いはず
										a<bから残りb'<11も全て決定出来る
									score-1で考えるとその間の差で誤差りそう
										t*t=scoreであるか異なるかで考えるべきな気がする
								t*t=scoreならt*t-1でまたぎt-1から下は全て使用可能
									あとはa
							8*9=72
							8はまず使えない
							7は10
							6は11
							5は12
							4は13
							3は14
							2は15
							で全て使える
							9の時に8が使用できないのだ
						5,10の時
						7
						7,7
						8,6=48
						9,5=45
						10,4=40
						11,3=33
						12,2=24
						13,1=13
						となると左側が7になるまでに10が使用出来ない場合を考える必要があるということである
						1,49
						2,24
						3,16
						4,12
						6,8
						二つ使えるな
							
F - Modularness
	https://atcoder.jp/contests/abc156/tasks/abc156_f
	長さkの数列d0,d1,...,d(k-1)がある
	以下のクエリq個を順に処理する
		i番目のクエリは3つの整数ni,xi,miからなる
		長さniの数列a0,a1,...,ani-1を
			aj={xi (j==0),aj-1+d(j-1)modk(0<j<=ni-1)}
		とする、(aj mod mi) < (aj+1 mod mi)であるような
			j(0<=j<=ni-1)の個数を出力する
		3 1
		3 1 4
		5 3 2
		この場合a0=3mod2=1,a1=(3+3)mod2=0,a2=0+1mod2=1
		a3=1+4mod2=1,a4=1+3mod0
		となる数列の数はkだがnはkを遥かに超える場合があるため、o(qn)ではTLEとなる
	依存するのは最初の数のみ
		mod miが厄介
			djmodmiは可能か？
				可能
		a0=1mod2=1,a1=1+1mod2=0,a2=0+1mod2=1,
		a3=1+0mod2=1,a4=1+1mod2=0
			となる
			ximodmiもok
			nimodmiは？一見出来ないように見える
		小さい数で考えると
			5 1
			1 1 1 1 1
			6 0 3
			1 2 0 1 2 0となる

			5 1
			1 1 2 1 1
			6 0 3
			
			1 1 2 1 1 1 1 2 1 1 1 1 2 1 1
			1 2 1 2 0 1 2 1 2 0 1 2 1 2 0 
			
			1 1 2 2 1 1 1 2 2 1 1 1 2 2 1
			1 2 1 0 1 2 0 2 1 2 0 1 0 2 1

			上の2 2 のところを見ると分かるが分岐点がある
			最初の2の時に0以下である場合、次は上昇する
			最初の2の時に1以上である場合、次は下降する
			piにおいて、次で上昇する場合、下降する場合、それぞれ訪れる回数はどれくらいか？
				をO(1)で求められれば一度のクエリはo(k)で終わる
					それは計算で求められそうにも思う
						一周分の和により増加量が分かる
							この増加量とmiのgcdが次に同じところに訪れた場合の位置の増加量として求められる
								0〜mi-1のいずれかになる
					iにおけるスタート地点、そこから何度訪れるか？
						スタート地点の計算は1周目の計算で出来るのでok
							その場所内で単調増加しないと考えた時の計算が難しいかもしれない
								mi=5と考えて
								3,1,4,2,0と移動する時、
								0~2までが増加するような場合
								4,3,2,1,0
								とかになると増加するわけでもないのでさらに厳しくはないだろうか
								最初に4だった場合、0から考えた時に4となるのは何周目か？
									を計算する時
										rを最小値、gを増加量、cを周回数として
										r+cg≡x mod mという式が立つ
											これは互いに素ではない
										(x-r)/g mod m?
								miの半分を超えるかどうか
									
F - Frog Jump
	https://atcoder.jp/contests/abc128/tasks/abc128_f
	0,1,...,n-1に蓮が配置されている
	任意の数A,Bを決め現在地xからx+A,x-Bと交互に移動する
		n-1に着いたらゴールで、すでに移動した場所、または蓮のない場所に止まったらマイナス10^100となる
	得点を最大化するA,Bの組み合わせを求め、その得点を求めよ
		難易度は高めな問題
	性質上A>Bである
		既に通ったところにBで落ちるという場合がダメなわけである
	1<=n<=10^5
		A=4,B=2に設定すると
			4→2
			2→6
			6→4と移動する
		A=4,B=3に設定すると
			4→1
			1→5
			5→2
			2→6と移動する
		最大公約数で移動していくのか？
			いや、A-Bずつ移動する
		AもBも等間隔
			0 5 3 8 6 11 9 14
			0 3 5 6 8 9 11 14
		Aは1ステップ目の位置からA-Bずつ
		Bは0からA-Bずつ
			0 6 4 10 8
		ゴールから考えると
			ステップ1で来る場合
			ステップ2で来る場合
			ステップ3で来る場合
			,......
			に関しては計算可能
				後ろから計算すればよい
			そのステップが可能な場所の限界は決まっている
				例えば5マスあるとき
					ステップ1で処理できるのは
						1ステップ目が
							4,3の時だけ
								これも計算出来そうだ
							3,4と移動するとき
							1*s移動する
							1*sで踏んで上りを踏んでいるか調べる
			上からと下からの累積をまず取る
				調和数になるので、計算量はそこまでいかないはず
					バリバリTLEになる
						累積がいらなかったようだ
					後2パターン残っている
			0 2 3 5
			6
			0 1 -1 -1 1 0
			12
			0 -1 1 1 -1 1 1 -1 1 1 -1 0				

F - Takahashi's Basics in Education and Learning
	https://atcoder.jp/contests/abc129/tasks/abc129_f
	長さLの等差数列s0,s1,s2,...,sL-1
	初項はA,項差はB,si=A+B*i
	数列の各項をつなげて出来る整数を考える
		この整数をMで割った余りはいくつか？
	1<=L,A,B<10^18
	2<=m<=10^9
	等差数列の要素は全て10^18未満
	要素数だけで単純に10^18ということはO(L)は不可
		法則性を見つけて処理させるしかなさそうである
	桁数は保ったまま交差分ずつ加算されていく感じ？
		等差数列の各要素を割った余りでつないでいっても同じになる
			これでO(L)には出来る
				更に工夫が必要である
					各項が交差分ずつ増えていった場合にどのような具合になるのか？
		行列べき乗かダブリングを使用するらしい
			橙レベルになるとそもそも頭に浮かばないことが多いなぁ


D - ロボット
	https://atcoder.jp/contests/abc027/tasks/abc027_d
	最初は0
	mで正または負の好きな方向に距離1だけ移動
	+で幸福度が+x変化
	-で幸福度が-x変化
	最終的に0に戻っている必要がある
		mが偶数個含まれる
			0からマイナスにも動ける
		単純に全パターンを考える時は
			mの個数をtとしたときにmCt
	最後のmが来るときは1,-1のどちらかにいる必要がある
		bitで考えると途中の値の保存が出来ない
		全ての移動に有向辺を貼るのはMLE
			メモ化も100000,100000になるため無理
		ある程度条件で縛る必要がありそう
			同じ形であれば真逆の結果となる
				ということは片側だけ考えれば良さそう
		0に戻った場青そこからの山は線対称とすることが出来る
			つまりその前の山があれば+でも-でも足す事が出来る
				ただし山の位置が確定していないので、
					これも難しそうである。
			実は+とマイナスを中心に考える？
				ある場所の+--が取る値は
					-x
				++--が取る値は0
				+++が取る値は+3x
				と決められる
				それぞれのxを全網羅出来ればクリアできるが
					そうはいかない
				ただしある区間については決められるわけだが
					全部分割されていたりすると計算量を削減する効果はない
				その地点のxはmの数に依存する、
					最初の0と最後の0に戻れる位置内で行う
						基本的には一つ飛ばしである
			絶対にマイナスになることはない
				マイナスになるということはプラスに出来る動きが可能ということである
			あとはプラスにしながら処理すればよい？
				貪欲に移動出来ないのが難しい点である
					ある地点での最大化は全体の最大化に関係するが
						ある地点でxの時に最大化なので、100000*50000となってTLE
			こうなると線形に決めていくしかないように思う
				
C - Triangular Relationship
	https://atcoder.jp/contests/abc108/tasks/arc102_a
	二個までは出来る
		なら3個も出来るのでは？
			n以下でkの倍数を洗い出す
				と思ったが1の倍数の時にTLEする
	あるxを決めた時にkの倍数であれば、他もkの倍数となる
	あるxを決めた時にkの倍数でなければ、他もkの倍数ではない
	例えばk=3の時にx=1と仮定すると
		他は2+knとなるが、それら二つはkの倍数にならない
	k=6の時2だった場合
		他は4+knとなる
			4,10,16,22となり他二つでkの倍数になれない
	あくまでも偶数でk/2の時だけだろう
		
F - Minimum Bounding Box
	https://atcoder.jp/contests/abc130/tasks/abc130_f
	(最大x-最小x)*(最大y-最小y)の最小を求めよ
		全て同じ間隔で移動するため、交差はあっても追い抜くということはない
			複数の点が同じ方向に移動するとき、逆向きに移動する点がその外側にいる時は、最大が大きくなる
				各点が交差する時を拾えばいい？
	R,L,U,Dそれぞれのまとまりを考えた時
	例えばRを考えた時
		Rmax,Rminに対してそれぞれのLがクロスするポイントがある
			その数は最大でも10^5
		秒は関係ないので、移動速度は考えなくてよく、距離がそれだけ移動するということを考える
			クロスするときにどれだけ移動するか？
				調べるのはRLUDそれぞれに対するxmax,ymaxで良いはず
					どれだけの距離を移動するかはそのxmax,ymaxでとれればいいはず
						
F - Colorful Tree
	https://atcoder.jp/contests/abc133/tasks/abc133_f
	木
	色ci,長さdi
	各辺の色は1~n-1
		q個の問いに答える
			j(1<=j<=q)
				色xjの全ての辺の長さがyjに変更されたと仮定して、二項間uj,vj間の距離を求めよ
	２項間なので、ダブリング(LCA)
		頂点1から対象の２頂点までの距離
			色は累積しておく
				累積はどうするか？
					ある頂点まで来た時に、そこにだけ保存しておければ良い気もするが全て保存されていないとだめっぽい
					ある色に対する距離
						mapで保存すると遅くなる？
							なるし、メモリ的にも無理では？
					色と長さの情報がそれぞれ必要となる
						色と長さだけで木を作る？
							深さが分かれば二分探索出来る
					ルートで分岐出来ていないとだめなので却下
						
U - Grouping
	https://atcoder.jp/contests/dp/tasks/dp_u
	bitでそれぞれ1グループとしたときの状態を前計算
	グループ分割をbit反転を使用して処理したと思うが思い出せず
		普通に

D - 漸化式
	https://atcoder.jp/contests/abc009/tasks/abc009_4
	半環とダブリングで処理する
		xorは+
		andは*
			と考え
				k+1,2kの式が出来れば終わり
					k+1はn+kのままである
				an+k=(c1 and a(n+k-1))xor (c2 and a(n+k-2)) xor ....
				an+k+1=(c1 and a(n+k)) xor (c2 and a(n+k-1)) xor ....
				an+k=(c1*a(n+k-1))+(c2*a(n+k-2))+
				=sum(i=1 to k)ci*a(n+k-i)
				=sum(i=1 to k)ci*sum(i=1 to k)a(n+i)
				=sum(i=1 to k)ci=t
				=t*sum(i=1 to k)a(n+k-i)
				a2(n+k)=t*sum(i=1 to k)a2(n+k-i)
				a(2n+2k-2i)
				sum(i=2 to 2k)a
				
F - Permutation Oddness
	https://atcoder.jp/contests/abc134/tasks/abc134_f
	k=sum(i=1to n)abs(i-ai)
		となる組み合わせはいくつあるか？
	1<=n<=50
	0<=k<=n^2
	制約が奇妙ではある
		1,2,3を用意して
		2,1,3とした場合は2
		2,3,1とした場合は4
		3,1,2とした場合も4
		3,2,1とした場合も4
		1,2,3,4を用意して
		4,3,2,1とした場合は8
		2,1,4,3=4
		3,4,1,2=8
		2,3,4,1=6
		奇数になることがなさそう
		2にするときは隣接しているところをひっくり返す以外の方法はない
		4にするときは1つ離れているところをひっくり返すか3つの塊をかぶらないように入れ替えるか
			隣接している2つを2箇所選んでそれぞれひっくり返す
		50!は無理
		自分の数字から離れた分だけ加算されると考える
			範囲で考えられる気がして来た
				がそれは最大値とか最小値を考える時な気もする
					k=n^2なので最大2500
			最初は一つと考える
			次は2つになるその時状態としては2と0が出来る
			次に3つになる、右側に来る場合、真ん中に来る場合、左側に来る場合
				左側に来る場合
					0,2,と4が観測できる
				真ん中に来るとき
					これが新しく、2だったものが一つ距離が離れるので4になる
						後は0のままのパターン
				右側に来るとき
					0,2,4が現れる
				数え方を工夫する必要がある
					n=3であれば
					0が一つ
					2が2つ
					4が3つというカウントになるはずである
						いくつか存在した時、全ての位置が異なる時、その時の値は同じになるか？
							ならない
					どうやってnを増やしていくかが課題
						最初を1として
						上に1増やしたものを付ける、下に1減らした物を付ける
							と考える
							すると1→1,2 または2,1となる
							次に同じように1,2,3のどれかをくっつけるのだが
							その前が2パターン存在しているわけだ
								1,2,3 1,3,2 2,3,1
								2,1,3 3,1,2 3,2,1
								これを考えるとうまくいく気がして来た
									3つめに追加するのが3である場合
										数は増えないはず
									2である場合
										数は割り込む形なので、2増える
									1である場合
										ほかの数も全て増加するはずで自分のところと合わせて4増える
										これをn^2分行えば良さそう
								最初は1のみで0の状態
									次は2,1か1,2の状態
										この時(2-1)*2が0→2に遷移
											　(2-2)*2が0→0に遷移
											最初の2はiで次はjである
												3 4が違う
								1,2,3 1,3,2 2,3,1
								2,1,3 3,1,2 3,2,1 3,1,2の時の4が取れていないのか？
								これはj=2の時に増えないといけない
								違うj=1の時の3,2,1からである
								2→4に遷移するパターン
								1,2
								2,1のパターン
								2,3,1の時に0→4
								3,2,1の時に2→4
								3,1,2の時に2→4
								1,3,2の時は0→2になる
									くっつく数字により補正がされるわけだ
										一番上のパターンは+1+1+2=+4
										2番目のパターンは+1-1+2=+2
										3番目は+1+0+1=+2
										4番目は+0+1+1=+2
											-が入る補正パターンをうまく考えられないか
										下から持ち上げる系の補正を考える
											上側に出ている数、下側に出ている数が管理出来ればいいが
												そこまで管理すると無理っぽい
												2を取るときはそれより小さい数が存在する
													1がそのままの時
														ほかの数は全て持ち上がる
													1が入れ替わっている時
														ほかの数は全て持ち上がる
													あれ？
														これだと2の時(i-2)が全て持ち上がるということである
															これであれば単純にi-2+(i-j)足すだけ
												1を取るときの方が問題だ
													増加量が変わるためである
										こうなると線形で考えるより
											最終形態から考えた方が楽なのでは？

D - 登山家
	https://atcoder.jp/contests/code-festival-2014-qualb/tasks/code_festival_qualB_d
	n個の山小屋が東西一直線に並んでいる
		1からnまで番号が付いている
			標高hiのところに建てられている
				いくつの山小屋を見ることが出来るのか気になる
	1<=n<=10^5
		単純に高さが低いところの山小屋は見えるがそこより高いところが登場するとその先は見えない
			両側から登りになっている分だけ連続で見えるので
				最大を管理しながら処理する？
					違うな
		
C - Swaps
	https://atcoder.jp/contests/nikkei2019-2-qual/tasks/nikkei2019_2_qual_c
	A1,....AnおよびB1,...,Bnが与えられる
		Ai<=Biとなるように出来るか判定してください。
	任意のx,yを選びAx,Ayを入れ替える
		一見好きに入れ替えられるので、Ai<=Biに出来るか
		であるが回数がn-2回までに制限されている
	まずソートした列でAi>Biとなっている箇所があればアウト
	小さい数で考えた時に
	1,2,3となっていて
	2,3,1となっている場合、2回以上必要となるためアウト
	6
		3 1 2 6 3 4
		2 2 8 3 4 3
		1 2 4 6 3 2
		2 2 3 3 4 8
	
D - Shortest Path on a Line
	https://atcoder.jp/contests/nikkei2019-2-qual/tasks/nikkei2019_2_qual_d
	一直線上に点があり1からnまで番号が付いている
		m回の操作によって辺を追加する
		Li,RiおよびCiを用いる
			Li<=s<=t<=Riなる整数の組(s,t)全てに対し、長さCiの辺を追加する
		単純に直線では考えられない
			重い辺から処理していき、上書きしていく
				前から処理をするのでは結局乗り換えをしたときにどっちを取るのかわからない
					辺を張るのが正解な気がする
						前後ろで辺を張る方法を考える
							l→lに貼るのと、r→rに貼る√を考えれば良さそう
								しかしそうなると
								1 10
								2 9
								3 8
								4 7
								のような形で作られた時
									1から先のl頂点全てに貼る
									2から先のl頂点全てに貼る
										といった形で死ぬ
								貼るべき頂点を限定出来ないだろうか
						上の辺を見た時に1→2→9→10のように戻るといったことはあり得ない
							1→10まで10のコスト行けたとして
							2→9がたとえ1のコストだったとしても
								9→10でまたコスト10を掛けてもとに戻る事はないためである
						一番左から自分の範囲が終わるまでに乗り換えるのは一度だけである
							何故なら自分の範囲が終わるまでに2度乗り換えるということは
								最初に乗り換えたコスト掛けなくとも2度目に乗り換えたところに到達可能で、乗り換え可能だからだ
						最初のところから複数本辺が伸びていたら？
						最初の辺が終了した時は？
							結局その先同じ状態になるだろう
		考え方を変えないとだめそう
			コスト0の辺も使ってうまく省略出来ないだろうか
				というか横の辺を貼れば良いのではないだろうか
			最初の頂点から次、横に伸びるところまで辺を貼るのはさっきと同じでは？
				うおおおお、「コスト0の逆辺を貼る」であった
					この発想は弱すぎる。。。毎週やろう


C - 行列のできるドーナツ屋
	https://atcoder.jp/contests/donuts-2015/tasks/donuts_2015_3
	自分は前に並んでいる誰より小さいかが高速に分かれば答えがすぐわかる
		登山家と同じ発想
			と思ったが
				4,3,2,5,6となっている時5からは1,4が見えている状態となる
				自分の一つ前は確実に見えている状態と言える
			    5
			    2 5 3 4 1
				なので一つ前から見えている大きいもの+1が答えとなる
					
C - ロミオとジュリエット
	https://atcoder.jp/contests/arc022/tasks/arc022_3
	任意の2頂点の最大距離を求めたい
		頂点1から出発し、一番遠いところを調べるのと
		二股以上になっている場所をみて遠い二点の和を調べる
			この二つの大きい方
		
E - Who Says a Pun?
	https://atcoder.jp/contests/abc141/tasks/abc141_e
	二つのlengthに対して、重ならないところで処理をする
		普通に出来てたと思っていたが、、、
			頭とけつからそれぞれ部分文字列を作ればいいような気がして来た。
			s[i] == s[j]が同じ時にs[i-1],s[j-1]を見て連続しているようなら処理している
			DPだが、今これが思いつけないのはなかなかである
				この問題はほかにも色々な解法があるようなので、色々試してみよう

C - Folia
	https://atcoder.jp/contests/nomura2020/tasks/nomura2020_c
	計算可能である
		葉と頂点になっている場所を計算すればよい
			頂点数は2x
		0=1
		1=2
		2=4
		n+1の整数列なので、最初の頂点は0
		直接の子の数は2以下なので最後が2^xでていない場合もあり得る
		2x-Adが枝の数
		後ろからやった方がよさそう
			各Adの数の限界は分かる
		0<=Ai<=10^8
		でn<=10^5までなので限界を見ることが出来るのは
			pow(2,63)以下から
			Anから考えて
		前から考えないと矛盾が起こりそう
		
B - Two Contests
	https://atcoder.jp/contests/agc040/tasks/agc040_b
	1からnまでの問題があり、2回のコンテストが行われる
	Li以上Ri以下の参加者は全員正解し、逆にそれ以外の参加者は誰も解けない
		2回のコンテストが行われる
			どちらのコンテストも１問以上出題される必要がある
		どの問題もちょうど1回のコンテストで出題されなくてはいけない
	２回のコンテストの楽しさの和としてありうる最大の値を求めよ
		4
		4 7
		1 4
		5 8
		2 5
	左昇順、右降順に並び替えると
		1 4
		2 5
		4 7
		5 8
	それぞれのコンテストの楽しさの和なので、良い感じにグループ分けしないといけない
		一番大きいものがある場合はそれと、他全部で分ける
	上の例を考えると
		1 4と他に分けると
		4+1=5
		1 4
		2 5とほかに分けると
		3+3=6
		となって一つずつ見ることが出来るが
			証明は出来るか？
		最初に1 4とほかで分けるとき
		グループ1のLiのMaxが1でRiのminが4
		もう片方はLiMax=5,Rimin=5で1となっている
		次に2 5がグループ1に移る
			するとLiMaxが2,Riminは4のままである
			Liの小さい順にグループを変更すると、
			片方のグループはLiが増加し、もう片方のグループは
				LiMaxは変化しないが、Riminが変化していく
			もう片方のグループのLiMaxは常に不変であるため、
				どのようにグループを分けても片方のLiMaxはこの値を取り続ける
					ついでに

C - 億マス計算
	https://atcoder.jp/contests/arc037/tasks/arc037_c
	長さnのaとbの配列のそれぞれを掛け合わせ、昇順に並べる。
		k番目は何か？
	aとbはソートしておく
		この数字は何番目か？の二分探索を行う
			cnt>=kの時に弾く
				
E - Tr/ee
	https://atcoder.jp/contests/arc103/tasks/arc103_c
	構築問題
		各頂点には1,2,...,nの番号が付いている
		各辺には1,2,...,n-1の番号が付いている
		siの文字が1であるとき木からある辺を除く事でサイズiの連結成分が作れる
		siの文字が0であるとき木からどのように辺を除いてもサイズiの連結成分が作れない
	あれば木を構築なければ-1を出力
		s1に関しては0はありえない
		snに関しては1はありえない
			この二つを取っかかりとすると
		s2=1の時、２頂点を結び、片方から1辺だけ伸びている状態
		s2=0の時、2頂点を結び、片方から2本以上の辺が伸びている状態
		1111111,......,0に関しては簡単で、全ての頂点が直線でつながっている状態
		
D - 壊れた電車
	https://atcoder.jp/contests/code-festival-2015-quala/tasks/codefestival_2015_qualA_d
	最短で何分で直せるか
		車両の移動に1分かかる
			1<=m<=10^5
			1<=n<=10^9
	ある整備士の隣どちらかが終点か、他の整備士がいるとき
		その逆方向に向かう
			単純に見るのであれば
				xxxxoxxxxxoxxxxx
				となっている場合
					o1が最初左に向かい
					o2が最初右に行く
					そのあと真ん中に戻っていきo1<x<o2を点検するとき
				4321o9(10)(11)(12)(11)o12345
				かかるので12が最大？
				4321o9(10)(11)321o789(10)(11)
				で11が最大
					外側に向かうのが最善ではなく、最初は短い方に向かうのが最善
				xxxxxxxoxxoxxx
					上のような場合はo1は左に進み、o1は左右の順番に進むのが最善
						それぞれが受け持つ量のバランスを取る
				xxxxxoxxx/xxxoxxxx/xxxxxoxxx
				11
				xxxxxoxxx/xxxoxxxx/xxxxxoxxxo
				11/10/11
				xxxxxo/xxxxxxox/xxxxxxxxo/xxxo
				5/8/8/3
					あるところでどちらかに行けない整備士があらわれると片側に思い切りのばすことが出来るようになる
				xxxxxoxxx/xxxoxxxx/xxxxxoxxxo
				xxxxxox/xxxxxox/xxxxxxxxo/xxxxo
				7/7/8/4
					しかしその量は隣が受け持っていた分を減らすことしかできない
						しかしこれで貪欲出来そうな気がする
				xxxxxxoxxxxxx
				18
					初期状態はこのようにする
				xxxxxxo/xxxxxxo
				6
				xxxxxxox/xxxxxox
				9
					受け持つ量の最大を計算していき、バランスが崩れたらリセット？
						厳しそうな気がする
				回数決めて二分探索
					それで頭から決定していくのが正しそう
						
					
			




		
	
				
				

				


						
								
						





	


					


