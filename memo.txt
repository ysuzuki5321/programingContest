E - Change a Little Bit
	https://atcoder.jp/contests/abc150/tasks/abc150_e
	0,1からなる長さNの異なる２つの数列S,T
		関数f(S,T)を以下のように定める
			SをTに変換する
				一つのiを変換するとき
					異なっている要素数をdとする
						ci*dがそのiの変換コストとなる
		f(S,T)の和を10^9+7で割った余りを計算する
	あるiが異なっている時、それが残りいくつの時に変換されるかを考える
		Ciをソートし、小さい順に考える
			Ci=a,Ci+1=bとしたとき
				a<=b
			異なっている要素数をdとすると
				d>d-1
			a*d+b*(d-1)と
			a*(d-1)+b*dのどちらが大きいかを考える
				ad+bd-b
				ad+bd-a
				となり
					ad+bd-b<=ad+bd-aである
		となるのでaの方が先に処理される
	例えばc1はあらゆるパターンで最初に処理される
	要素数をxとすると
		x個異なっているのは2パターン
		x-1個異なっているのは2*xC1パターン
			その中に自分が含まれているのは2*(x-1)C1
		x-2個異なっているは2*xC2パターン
			その中に自分が含まれているのは2*(x-1)C2
			,,,,,,
		自分より右側のあらゆるパターンにより加算される
			左側は各パターンに掛け算される
			2^pで表現できるか？
		異なっている場所を1で表現し要素3で考えると
			100
			010
			001
			110
			101
			011
			111
			12である
				3+6+3
			要素数2になると
			10
			01
			11
			2+2
			で4である
			要素数1は1
			要素数4は？
				1000
				0100
				0010
				0001
				1100
				1010
				1001
				0110
				0101
				0011
				1110
				1101
				1011
				0111
				1111
				4+12+12+4=32
					2項係数っぽい
			漸化式に出来そう
				1の時は1
				2の時は
					前の1をそのまま使用する
					前の1を使用して自分も足す
					前の1を使用しない
					パターン数3
				3の時は
					2をそのまま使用する = 4
					2を使用して自分を足す = 3+4
					2を使用しない = 1
					パターン数3+3+1=7
					総和12
				4の時は
					1.12
					2.12+7
					3.1
					p=7+7+1=15
				,,,,,,
				で組み立てられる
					パターン数と総和をそれぞれ配列で保持する
			AC!!!!!!!!

F - Small Products
	https://atcoder.jp/contests/abc132/tasks/abc132_f
	整数k個
	隣接して並んでいるどの二つの数の積もN以下であるものの個数を10^9+7で割った余りで求めよ
	1<=k<=100
	1<=n<=10^9
		隣り合っている数がどのような状態になるかを考える必要がある
			例えばn=6の時
				1 1
				1 2
				1 3
				1 4
				1 5
				1 6
				2 1
				2 2
				2 3
				3 1
				3 2
				4 1
				5 1
				6 1
			しかしさらに隣が加わると
				dpで畳み込みたくなる
					が、nが巨大
						これをどう処理するか
							sqrtまで処理出来れば行けるようにならないか？
			約数でも良さそう
				例えばn>=x>n/2なるxは全て1にならないといけない
					n/2>=x>n/3なるxは全て1か2にならないといけない
					という風に上から下への計算は出来る
					1はnまでの数全てになれる
					同じ形がひたすら続くので３つ目までカウント出来ればあとは式に出来るはず
						1 (1~6)
						2 (1~3)
						3 (1~2)
						4 1
						5 1
						6 1
					これをグループに分ける
						1        ,2 ,3 ,(4,5,6)
						/(4,5,6) /3 /2 /1
						1 6
						2 3
						3 2
						(4,5,6) 1*3
					もう少し数が大きいと分かりやすそう
					とりあえずn=6で3つめは
						1 6 から 6つずつ全てのグループに入る
						2 3 から 3つずつ1,2,3のグループに入る
						3 2 から 2つずつ1,2のグループに入る
						(4,5,6)から 1*3ずつ1のグループに入る
						o(k√nlog√n)
					グループの分割方法
						n=7の時
						1 (4,5,6,7)
						2 3
						3 2
						(4,5,6,7) 1
						n=10の時
						1 (6,7,8,9,10)
						2 (4,5)
						3 3
						(4,5) 2
						(6,7,8,9,10) 1
						半分になる
					しかもこれは約数ではない
						sqrt(n)をまたいで二つに分かれそう
						n=10
						g1 : 1
						g2 : 1
						g3 : 1
						g4 : 2
						g5 : 5
						10/1=10
						10/2=5
						10/3=3
						10/4=2
						10/5=2
						10/6=1
						10/7=1
						10/8=1
						10/9=1
						10/10=1

D - Worst Case
	https://atcoder.jp/contests/abc093/tasks/arc094_b
	一度解いているらしいが2月にやった時は完全に忘れていて解けなかったまま放置されてた
	2回のコンテストでAi位、２回目のコンテストでBi位である
	スコアは順位を掛け合わせた数
		1<=ai<=10^9 1<=bi<=10^9なので最大でも10^18
	これは2分探索で行けるのではなかろうか？
		掛け合わせた値より下のスコアの者たちはどれくらいおるかである
			小さい数字で考えるべき
				5位7位を取ったとするとスコアは35である
				これより小さい数の組み合わせで最大を取ろうとすると
					1位に対して34が割り当てられ
					2位に対して17が割り当てられ
					3位に対して34/3の11が割り当てられ
					4位に対して34/4の8が割り当てられ
					同様に
					5,7
					6,5
					7,4
					8,3
					9,2
					10,1
					となり10人が取れるが、自分の順位は省かれるため
					9となる予感
					3,3で4となっている
					1,8
					2,4
					4,2
					5,1で4だろう
					4,11で11である
					最大は44
					1,43
					2,21
					3,14
					5,8
					6,7
					7,6
					8,5
					9,4
					10,3
					11,2
					12,1
					である
					片側でどこまで取れるかで完成できる
						まず大小を入れ替える
							a>bとなっている場合、交換する
							組み合わせにおいてa'*b'かつa'>b'でa'-b'が一番小さいところを考える
							√(score-1)=tが近い
								t*t=score-1であるかどうか
					43以下の数字についてみる
						7*6=42でまたいで6要素は可となる
						√43=6となる
						6*6と7*6を比較する
							これは二つ離れられない？
								score-1とscoreは1しか変わらない
									つまり平方数はほぼ同じはずである
							144=12*12
							11*13=143となる
							143はsqrt(143)を計算すると11になってしまい
							2つ離れる
								しかし、11は決定する
									というか12*11で良いはず
										a<bから残りb'<11も全て決定出来る
									score-1で考えるとその間の差で誤差りそう
										t*t=scoreであるか異なるかで考えるべきな気がする
								t*t=scoreならt*t-1でまたぎt-1から下は全て使用可能
									あとはa
							8*9=72
							8はまず使えない
							7は10
							6は11
							5は12
							4は13
							3は14
							2は15
							で全て使える
							9の時に8が使用できないのだ
						5,10の時
						7
						7,7
						8,6=48
						9,5=45
						10,4=40
						11,3=33
						12,2=24
						13,1=13
						となると左側が7になるまでに10が使用出来ない場合を考える必要があるということである
						1,49
						2,24
						3,16
						4,12
						6,8
						二つ使えるな
							
F - Modularness
	https://atcoder.jp/contests/abc156/tasks/abc156_f
	長さkの数列d0,d1,...,d(k-1)がある
	以下のクエリq個を順に処理する
		i番目のクエリは3つの整数ni,xi,miからなる
		長さniの数列a0,a1,...,ani-1を
			aj={xi (j==0),aj-1+d(j-1)modk(0<j<=ni-1)}
		とする、(aj mod mi) < (aj+1 mod mi)であるような
			j(0<=j<=ni-1)の個数を出力する
		3 1
		3 1 4
		5 3 2
		この場合a0=3mod2=1,a1=(3+3)mod2=0,a2=0+1mod2=1
		a3=1+4mod2=1,a4=1+3mod0
		となる数列の数はkだがnはkを遥かに超える場合があるため、o(qn)ではTLEとなる
	依存するのは最初の数のみ
		mod miが厄介
			djmodmiは可能か？
				可能
		a0=1mod2=1,a1=1+1mod2=0,a2=0+1mod2=1,
		a3=1+0mod2=1,a4=1+1mod2=0
			となる
			ximodmiもok
			nimodmiは？一見出来ないように見える
		小さい数で考えると
			5 1
			1 1 1 1 1
			6 0 3
			1 2 0 1 2 0となる

			5 1
			1 1 2 1 1
			6 0 3
			
			1 1 2 1 1 1 1 2 1 1 1 1 2 1 1
			1 2 1 2 0 1 2 1 2 0 1 2 1 2 0 
			
			1 1 2 2 1 1 1 2 2 1 1 1 2 2 1
			1 2 1 0 1 2 0 2 1 2 0 1 0 2 1

			上の2 2 のところを見ると分かるが分岐点がある
			最初の2の時に0以下である場合、次は上昇する
			最初の2の時に1以上である場合、次は下降する
			piにおいて、次で上昇する場合、下降する場合、それぞれ訪れる回数はどれくらいか？
				をO(1)で求められれば一度のクエリはo(k)で終わる
					それは計算で求められそうにも思う
						一周分の和により増加量が分かる
							この増加量とmiのgcdが次に同じところに訪れた場合の位置の増加量として求められる
								0〜mi-1のいずれかになる
					iにおけるスタート地点、そこから何度訪れるか？
						スタート地点の計算は1周目の計算で出来るのでok
							その場所内で単調増加しないと考えた時の計算が難しいかもしれない
								mi=5と考えて
								3,1,4,2,0と移動する時、
								0~2までが増加するような場合
								4,3,2,1,0
								とかになると増加するわけでもないのでさらに厳しくはないだろうか
								最初に4だった場合、0から考えた時に4となるのは何周目か？
									を計算する時
										rを最小値、gを増加量、cを周回数として
										r+cg≡x mod mという式が立つ
											これは互いに素ではない
										(x-r)/g mod m?
								miの半分を超えるかどうか
									
F - Frog Jump
	https://atcoder.jp/contests/abc128/tasks/abc128_f
	0,1,...,n-1に蓮が配置されている
	任意の数A,Bを決め現在地xからx+A,x-Bと交互に移動する
		n-1に着いたらゴールで、すでに移動した場所、または蓮のない場所に止まったらマイナス10^100となる
	得点を最大化するA,Bの組み合わせを求め、その得点を求めよ
		難易度は高めな問題
	性質上A>Bである
		既に通ったところにBで落ちるという場合がダメなわけである
	1<=n<=10^5
		A=4,B=2に設定すると
			4→2
			2→6
			6→4と移動する
		A=4,B=3に設定すると
			4→1
			1→5
			5→2
			2→6と移動する
		最大公約数で移動していくのか？
			いや、A-Bずつ移動する
		AもBも等間隔
			0 5 3 8 6 11 9 14
			0 3 5 6 8 9 11 14
		Aは1ステップ目の位置からA-Bずつ
		Bは0からA-Bずつ
			0 6 4 10 8
		ゴールから考えると
			ステップ1で来る場合
			ステップ2で来る場合
			ステップ3で来る場合
			,......
			に関しては計算可能
				後ろから計算すればよい
			そのステップが可能な場所の限界は決まっている
				例えば5マスあるとき
					ステップ1で処理できるのは
						1ステップ目が
							4,3の時だけ
								これも計算出来そうだ
							3,4と移動するとき
							1*s移動する
							1*sで踏んで上りを踏んでいるか調べる
			上からと下からの累積をまず取る
				調和数になるので、計算量はそこまでいかないはず
					バリバリTLEになる
						累積がいらなかったようだ
					後2パターン残っている
			0 2 3 5
			6
			0 1 -1 -1 1 0
			12
			0 -1 1 1 -1 1 1 -1 1 1 -1 0				

F - Takahashi's Basics in Education and Learning
	https://atcoder.jp/contests/abc129/tasks/abc129_f
	長さLの等差数列s0,s1,s2,...,sL-1
	初項はA,項差はB,si=A+B*i
	数列の各項をつなげて出来る整数を考える
		この整数をMで割った余りはいくつか？
	1<=L,A,B<10^18
	2<=m<=10^9
	等差数列の要素は全て10^18未満
	要素数だけで単純に10^18ということはO(L)は不可
		法則性を見つけて処理させるしかなさそうである
	桁数は保ったまま交差分ずつ加算されていく感じ？
		等差数列の各要素を割った余りでつないでいっても同じになる
			これでO(L)には出来る
				更に工夫が必要である
					各項が交差分ずつ増えていった場合にどのような具合になるのか？
		行列べき乗かダブリングを使用するらしい
			橙レベルになるとそもそも頭に浮かばないことが多いなぁ

F - Minimum Bounding Box
	https://atcoder.jp/contests/abc130/tasks/abc130_f
	(最大x-最小x)*(最大y-最小y)の最小を求めよ
		全て同じ間隔で移動するため、交差はあっても追い抜くということはない
			複数の点が同じ方向に移動するとき、逆向きに移動する点がその外側にいる時は、最大が大きくなる
				各点が交差する時を拾えばいい？
					
D - ロボット
	https://atcoder.jp/contests/abc027/tasks/abc027_d
	最初は0
	mで正または負の好きな方向に距離1だけ移動
	+で幸福度が+x変化
	-で幸福度が-x変化
	最終的に0に戻っている必要がある
		mが偶数個含まれる
			0からマイナスにも動ける
		単純に全パターンを考える時は
			mの個数をtとしたときにmCt
	最後のmが来るときは1,-1のどちらかにいる必要がある
		bitで考えると途中の値の保存が出来ない
		全ての移動に有向辺を貼るのはMLE
			メモ化も100000,100000になるため無理
		ある程度条件で縛る必要がありそう
			同じ形であれば真逆の結果となる
				ということは片側だけ考えれば良さそう
		0に戻った場青そこからの山は線対称とすることが出来る
			つまりその前の山があれば+でも-でも足す事が出来る
				ただし山の位置が確定していないので、
					これも難しそうである。
			実は+とマイナスを中心に考える？
				ある場所の+--が取る値は
					-x
				++--が取る値は0
				+++が取る値は+3x
				と決められる
				それぞれのxを全網羅出来ればクリアできるが
					そうはいかない
				ただしある区間については決められるわけだが
					全部分割されていたりすると計算量を削減する効果はない
				その地点のxはmの数に依存する、
					最初の0と最後の0に戻れる位置内で行う
						基本的には一つ飛ばしである
			絶対にマイナスになることはない
				マイナスになるということはプラスに出来る動きが可能ということである
			あとはプラスにしながら処理すればよい？
				貪欲に移動出来ないのが難しい点である
					ある地点での最大化は全体の最大化に関係するが
						ある地点でxの時に最大化なので、100000*50000となってTLE
			こうなると線形に決めていくしかないように思う
				
					
				
				

				


						
								
						





	


					


