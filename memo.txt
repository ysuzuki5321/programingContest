E - Change a Little Bit
	https://atcoder.jp/contests/abc150/tasks/abc150_e
	0,1からなる長さNの異なる２つの数列S,T
		関数f(S,T)を以下のように定める
			SをTに変換する
				一つのiを変換するとき
					異なっている要素数をdとする
						ci*dがそのiの変換コストとなる
		f(S,T)の和を10^9+7で割った余りを計算する
	あるiが異なっている時、それが残りいくつの時に変換されるかを考える
		Ciをソートし、小さい順に考える
			Ci=a,Ci+1=bとしたとき
				a<=b
			異なっている要素数をdとすると
				d>d-1
			a*d+b*(d-1)と
			a*(d-1)+b*dのどちらが大きいかを考える
				ad+bd-b
				ad+bd-a
				となり
					ad+bd-b<=ad+bd-aである
		となるのでaの方が先に処理される
	例えばc1はあらゆるパターンで最初に処理される
	要素数をxとすると
		x個異なっているのは2パターン
		x-1個異なっているのは2*xC1パターン
			その中に自分が含まれているのは2*(x-1)C1
		x-2個異なっているは2*xC2パターン
			その中に自分が含まれているのは2*(x-1)C2
			,,,,,,
		自分より右側のあらゆるパターンにより加算される
			左側は各パターンに掛け算される
			2^pで表現できるか？
		異なっている場所を1で表現し要素3で考えると
			100
			010
			001
			110
			101
			011
			111
			12である
				3+6+3
			要素数2になると
			10
			01
			11
			2+2
			で4である
			要素数1は1
			要素数4は？
				1000
				0100
				0010
				0001
				1100
				1010
				1001
				0110
				0101
				0011
				1110
				1101
				1011
				0111
				1111
				4+12+12+4=32
					2項係数っぽい
			漸化式に出来そう
				1の時は1
				2の時は
					前の1をそのまま使用する
					前の1を使用して自分も足す
					前の1を使用しない
					パターン数3
				3の時は
					2をそのまま使用する = 4
					2を使用して自分を足す = 3+4
					2を使用しない = 1
					パターン数3+3+1=7
					総和12
				4の時は
					1.12
					2.12+7
					3.1
					p=7+7+1=15
				,,,,,,
				で組み立てられる
					パターン数と総和をそれぞれ配列で保持する
			AC!!!!!!!!

F - Small Products
	https://atcoder.jp/contests/abc132/tasks/abc132_f
	整数k個
	隣接して並んでいるどの二つの数の積もN以下であるものの個数を10^9+7で割った余りで求めよ
	1<=k<=100
	1<=n<=10^9
		隣り合っている数がどのような状態になるかを考える必要がある
			例えばn=6の時
				1 1
				1 2
				1 3
				1 4
				1 5
				1 6
				2 1
				2 2
				2 3
				3 1
				3 2
				4 1
				5 1
				6 1
			しかしさらに隣が加わると
				dpで畳み込みたくなる
					が、nが巨大
						これをどう処理するか
							sqrtまで処理出来れば行けるようにならないか？
			約数でも良さそう
				例えばn>=x>n/2なるxは全て1にならないといけない
					n/2>=x>n/3なるxは全て1か2にならないといけない
					という風に上から下への計算は出来る
					1はnまでの数全てになれる
					同じ形がひたすら続くので３つ目までカウント出来ればあとは式に出来るはず
						1 (1~6)
						2 (1~3)
						3 (1~2)
						4 1
						5 1
						6 1
					これをグループに分ける
						1        ,2 ,3 ,(4,5,6)
						/(4,5,6) /3 /2 /1
						1 6
						2 3
						3 2
						(4,5,6) 1*3
					もう少し数が大きいと分かりやすそう
					とりあえずn=6で3つめは
						1 6 から 6つずつ全てのグループに入る
						2 3 から 3つずつ1,2,3のグループに入る
						3 2 から 2つずつ1,2のグループに入る
						(4,5,6)から 1*3ずつ1のグループに入る
						o(k√nlog√n)
					グループの分割方法
						n=7の時
						1 (4,5,6,7)
						2 3
						3 2
						(4,5,6,7) 1
						n=10の時
						1 (6,7,8,9,10)
						2 (4,5)
						3 3
						(4,5) 2
						(6,7,8,9,10) 1
						半分になる
					しかもこれは約数ではない
						sqrt(n)をまたいで二つに分かれそう
						n=10
						g1 : 1
						g2 : 1
						g3 : 1
						g4 : 2
						g5 : 5
						10/1=10
						10/2=5
						10/3=3
						10/4=2
						10/5=2
						10/6=1
						10/7=1
						10/8=1
						10/9=1
						10/10=1

D - Worst Case
	https://atcoder.jp/contests/abc093/tasks/arc094_b
	一度解いているらしいが2月にやった時は完全に忘れていて解けなかったまま放置されてた
	2回のコンテストでAi位、２回目のコンテストでBi位である
	スコアは順位を掛け合わせた数
		1<=ai<=10^9 1<=bi<=10^9なので最大でも10^18
	これは2分探索で行けるのではなかろうか？
		掛け合わせた値より下のスコアの者たちはどれくらいおるかである
			小さい数字で考えるべき
				5位7位を取ったとするとスコアは35である
				これより小さい数の組み合わせで最大を取ろうとすると
					1位に対して34が割り当てられ
					2位に対して17が割り当てられ
					3位に対して34/3の11が割り当てられ
					4位に対して34/4の8が割り当てられ
					同様に
					5,7
					6,5
					7,4
					8,3
					9,2
					10,1
					となり10人が取れるが、自分の順位は省かれるため
					9となる予感
					3,3で4となっている
					1,8
					2,4
					4,2
					5,1で4だろう
					4,11で11である
					最大は44
					1,43
					2,21
					3,14
					5,8
					6,7
					7,6
					8,5
					9,4
					10,3
					11,2
					12,1
					である
					片側でどこまで取れるかで完成できる
						まず大小を入れ替える
							a>bとなっている場合、交換する
							組み合わせにおいてa'*b'かつa'>b'でa'-b'が一番小さいところを考える
							√(score-1)=tが近い
								t*t=score-1であるかどうか
					43以下の数字についてみる
						7*6=42でまたいで6要素は可となる
						√43=6となる
						6*6と7*6を比較する
							これは二つ離れられない？
								score-1とscoreは1しか変わらない
									つまり平方数はほぼ同じはずである
							144=12*12
							11*13=143となる
							143はsqrt(143)を計算すると11になってしまい
							2つ離れる
								しかし、11は決定する
									というか12*11で良いはず
										a<bから残りb'<11も全て決定出来る
									score-1で考えるとその間の差で誤差りそう
										t*t=scoreであるか異なるかで考えるべきな気がする
								t*t=scoreならt*t-1でまたぎt-1から下は全て使用可能
									あとはa
							8*9=72
							8はまず使えない
							7は10
							6は11
							5は12
							4は13
							3は14
							2は15
							で全て使える
							9の時に8が使用できないのだ
						5,10の時
						7
						7,7
						8,6=48
						9,5=45
						10,4=40
						11,3=33
						12,2=24
						13,1=13
						となると左側が7になるまでに10が使用出来ない場合を考える必要があるということである
						1,49
						2,24
						3,16
						4,12
						6,8
						二つ使えるな
							
F - Modularness
	https://atcoder.jp/contests/abc156/tasks/abc156_f
	長さkの数列d0,d1,...,d(k-1)がある
	以下のクエリq個を順に処理する
		i番目のクエリは3つの整数ni,xi,miからなる
		長さniの数列a0,a1,...,ani-1を
			aj={xi (j==0),aj-1+d(j-1)modk(0<j<=ni-1)}
		とする、(aj mod mi) < (aj+1 mod mi)であるような
			j(0<=j<=ni-1)の個数を出力する
		3 1
		3 1 4
		5 3 2
		この場合a0=3mod2=1,a1=(3+3)mod2=0,a2=0+1mod2=1
		a3=1+4mod2=1,a4=1+3mod0
		となる数列の数はkだがnはkを遥かに超える場合があるため、o(qn)ではTLEとなる
	依存するのは最初の数のみ
		mod miが厄介
			djmodmiは可能か？
				可能
		a0=1mod2=1,a1=1+1mod2=0,a2=0+1mod2=1,
		a3=1+0mod2=1,a4=1+1mod2=0
			となる
			ximodmiもok
			nimodmiは？一見出来ないように見える
		小さい数で考えると
			5 1
			1 1 1 1 1
			6 0 3
			1 2 0 1 2 0となる

			5 1
			1 1 2 1 1
			6 0 3
			
			1 1 2 1 1 1 1 2 1 1 1 1 2 1 1
			1 2 1 2 0 1 2 1 2 0 1 2 1 2 0 
			
			1 1 2 2 1 1 1 2 2 1 1 1 2 2 1
			1 2 1 0 1 2 0 2 1 2 0 1 0 2 1

			上の2 2 のところを見ると分かるが分岐点がある
			最初の2の時に0以下である場合、次は上昇する
			最初の2の時に1以上である場合、次は下降する
			piにおいて、次で上昇する場合、下降する場合、それぞれ訪れる回数はどれくらいか？
				をO(1)で求められれば一度のクエリはo(k)で終わる
					それは計算で求められそうにも思う
						一周分の和により増加量が分かる
							この増加量とmiのgcdが次に同じところに訪れた場合の位置の増加量として求められる
								0〜mi-1のいずれかになる
					iにおけるスタート地点、そこから何度訪れるか？
						スタート地点の計算は1周目の計算で出来るのでok
							その場所内で単調増加しないと考えた時の計算が難しいかもしれない
								mi=5と考えて
								3,1,4,2,0と移動する時、
								0~2までが増加するような場合
								4,3,2,1,0
								とかになると増加するわけでもないのでさらに厳しくはないだろうか
								最初に4だった場合、0から考えた時に4となるのは何周目か？
									を計算する時
										rを最小値、gを増加量、cを周回数として
										r+cg≡x mod mという式が立つ
											これは互いに素ではない
										(x-r)/g mod m?

													

									
								


				


						
								
						




	


					


