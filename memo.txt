E - Change a Little Bit
	https://atcoder.jp/contests/abc150/tasks/abc150_e
	0,1からなる長さNの異なる２つの数列S,T
		関数f(S,T)を以下のように定める
			SをTに変換する
				一つのiを変換するとき
					異なっている要素数をdとする
						ci*dがそのiの変換コストとなる
		f(S,T)の和を10^9+7で割った余りを計算する
	あるiが異なっている時、それが残りいくつの時に変換されるかを考える
		Ciをソートし、小さい順に考える
			Ci=a,Ci+1=bとしたとき
				a<=b
			異なっている要素数をdとすると
				d>d-1
			a*d+b*(d-1)と
			a*(d-1)+b*dのどちらが大きいかを考える
				ad+bd-b
				ad+bd-a
				となり
					ad+bd-b<=ad+bd-aである
		となるのでaの方が先に処理される
	例えばc1はあらゆるパターンで最初に処理される
	要素数をxとすると
		x個異なっているのは2パターン
		x-1個異なっているのは2*xC1パターン
			その中に自分が含まれているのは2*(x-1)C1
		x-2個異なっているは2*xC2パターン
			その中に自分が含まれているのは2*(x-1)C2
			,,,,,,
		自分より右側のあらゆるパターンにより加算される
			左側は各パターンに掛け算される
			2^pで表現できるか？
		異なっている場所を1で表現し要素3で考えると
			100
			010
			001
			110
			101
			011
			111
			12である
				3+6+3
			要素数2になると
			10
			01
			11
			2+2
			で4である
			要素数1は1
			要素数4は？
				1000
				0100
				0010
				0001
				1100
				1010
				1001
				0110
				0101
				0011
				1110
				1101
				1011
				0111
				1111
				4+12+12+4=32
					2項係数っぽい
			漸化式に出来そう
				1の時は1
				2の時は
					前の1をそのまま使用する
					前の1を使用して自分も足す
					前の1を使用しない
					パターン数3
				3の時は
					2をそのまま使用する = 4
					2を使用して自分を足す = 3+4
					2を使用しない = 1
					パターン数3+3+1=7
					総和12
				4の時は
					1.12
					2.12+7
					3.1
					p=7+7+1=15
				,,,,,,
				で組み立てられる
					パターン数と総和をそれぞれ配列で保持する
			AC!!!!!!!!

F - Small Products
	https://atcoder.jp/contests/abc132/tasks/abc132_f
	整数k個
	隣接して並んでいるどの二つの数の積もN以下であるものの個数を10^9+7で割った余りで求めよ
	1<=k<=100
	1<=n<=10^9
		隣り合っている数がどのような状態になるかを考える必要がある
			例えばn=6の時
				1 1
				1 2
				1 3
				1 4
				1 5
				1 6
				2 1
				2 2
				2 3
				3 1
				3 2
				4 1
				5 1
				6 1
			しかしさらに隣が加わると
				dpで畳み込みたくなる
					が、nが巨大
						これをどう処理するか
							sqrtまで処理出来れば行けるようにならないか？
			約数でも良さそう
				例えばn>=x>n/2なるxは全て1にならないといけない
					n/2>=x>n/3なるxは全て1か2にならないといけない
					という風に上から下への計算は出来る
					1はnまでの数全てになれる
					同じ形がひたすら続くので３つ目までカウント出来ればあとは式に出来るはず
						1 (1~6)
						2 (1~3)
						3 (1~2)
						4 1
						5 1
						6 1
					これをグループに分ける
						1        ,2 ,3 ,(4,5,6)
						/(4,5,6) /3 /2 /1
						1 6
						2 3
						3 2
						(4,5,6) 1*3
					もう少し数が大きいと分かりやすそう
					とりあえずn=6で3つめは
						1 6 から 6つずつ全てのグループに入る
						2 3 から 3つずつ1,2,3のグループに入る
						3 2 から 2つずつ1,2のグループに入る
						(4,5,6)から 1*3ずつ1のグループに入る
						o(k√nlog√n)
					グループの分割方法
						n=7の時
						1 (4,5,6,7)
						2 3
						3 2
						(4,5,6,7) 1
						n=10の時
						1 (6,7,8,9,10)
						2 (4,5)
						3 3
						(4,5) 2
						(6,7,8,9,10) 1
						半分になる
					しかもこれは約数ではない
						sqrt(n)をまたいで二つに分かれそう
						n=10
						g1 : 1
						g2 : 1
						g3 : 1
						g4 : 2
						g5 : 5
						10/1=10
						10/2=5
						10/3=3
						10/4=2
						10/5=2
						10/6=1
						10/7=1
						10/8=1
						10/9=1
						10/10=1

D - Worst Case
	https://atcoder.jp/contests/abc093/tasks/arc094_b
	一度解いているらしいが2月にやった時は完全に忘れていて解けなかったまま放置されてた
	2回のコンテストでAi位、２回目のコンテストでBi位である
	スコアは順位を掛け合わせた数
		1<=ai<=10^9 1<=bi<=10^9なので最大でも10^18
	これは2分探索で行けるのではなかろうか？
		掛け合わせた値より下のスコアの者たちはどれくらいおるかである
			小さい数字で考えるべき
				5位7位を取ったとするとスコアは35である
				これより小さい数の組み合わせで最大を取ろうとすると
					1位に対して34が割り当てられ
					2位に対して17が割り当てられ
					3位に対して34/3の11が割り当てられ
					4位に対して34/4の8が割り当てられ
					同様に
					5,7
					6,5
					7,4
					8,3
					9,2
					10,1
					となり10人が取れるが、自分の順位は省かれるため
					9となる予感
					3,3で4となっている
					1,8
					2,4
					4,2
					5,1で4だろう
					4,11で11である
					最大は44
					1,43
					2,21
					3,14
					5,8
					6,7
					7,6
					8,5
					9,4
					10,3
					11,2
					12,1
					である
					片側でどこまで取れるかで完成できる
						まず大小を入れ替える
							a>bとなっている場合、交換する
							組み合わせにおいてa'*b'かつa'>b'でa'-b'が一番小さいところを考える
							√(score-1)=tが近い
								t*t=score-1であるかどうか
					43以下の数字についてみる
						7*6=42でまたいで6要素は可となる
						√43=6となる
						6*6と7*6を比較する
							これは二つ離れられない？
								score-1とscoreは1しか変わらない
									つまり平方数はほぼ同じはずである
							144=12*12
							11*13=143となる
							143はsqrt(143)を計算すると11になってしまい
							2つ離れる
								しかし、11は決定する
									というか12*11で良いはず
										a<bから残りb'<11も全て決定出来る
									score-1で考えるとその間の差で誤差りそう
										t*t=scoreであるか異なるかで考えるべきな気がする
								t*t=scoreならt*t-1でまたぎt-1から下は全て使用可能
									あとはa
							8*9=72
							8はまず使えない
							7は10
							6は11
							5は12
							4は13
							3は14
							2は15
							で全て使える
							9の時に8が使用できないのだ
						5,10の時
						7
						7,7
						8,6=48
						9,5=45
						10,4=40
						11,3=33
						12,2=24
						13,1=13
						となると左側が7になるまでに10が使用出来ない場合を考える必要があるということである
						1,49
						2,24
						3,16
						4,12
						6,8
						二つ使えるな
							
F - Modularness
	https://atcoder.jp/contests/abc156/tasks/abc156_f
	長さkの数列d0,d1,...,d(k-1)がある
	以下のクエリq個を順に処理する
		i番目のクエリは3つの整数ni,xi,miからなる
		長さniの数列a0,a1,...,ani-1を
			aj={xi (j==0),aj-1+d(j-1)modk(0<j<=ni-1)}
		とする、(aj mod mi) < (aj+1 mod mi)であるような
			j(0<=j<=ni-1)の個数を出力する
		3 1
		3 1 4
		5 3 2
		この場合a0=3mod2=1,a1=(3+3)mod2=0,a2=0+1mod2=1
		a3=1+4mod2=1,a4=1+3mod0
		となる数列の数はkだがnはkを遥かに超える場合があるため、o(qn)ではTLEとなる
	依存するのは最初の数のみ
		mod miが厄介
			djmodmiは可能か？
				可能
		a0=1mod2=1,a1=1+1mod2=0,a2=0+1mod2=1,
		a3=1+0mod2=1,a4=1+1mod2=0
			となる
			ximodmiもok
			nimodmiは？一見出来ないように見える
		小さい数で考えると
			5 1
			1 1 1 1 1
			6 0 3
			1 2 0 1 2 0となる

			5 1
			1 1 2 1 1
			6 0 3
			
			1 1 2 1 1 1 1 2 1 1 1 1 2 1 1
			1 2 1 2 0 1 2 1 2 0 1 2 1 2 0 
			
			1 1 2 2 1 1 1 2 2 1 1 1 2 2 1
			1 2 1 0 1 2 0 2 1 2 0 1 0 2 1

			上の2 2 のところを見ると分かるが分岐点がある
			最初の2の時に0以下である場合、次は上昇する
			最初の2の時に1以上である場合、次は下降する
			piにおいて、次で上昇する場合、下降する場合、それぞれ訪れる回数はどれくらいか？
				をO(1)で求められれば一度のクエリはo(k)で終わる
					それは計算で求められそうにも思う
						一周分の和により増加量が分かる
							この増加量とmiのgcdが次に同じところに訪れた場合の位置の増加量として求められる
								0～mi-1のいずれかになる
					iにおけるスタート地点、そこから何度訪れるか？
						スタート地点の計算は1周目の計算で出来るのでok
							その場所内で単調増加しないと考えた時の計算が難しいかもしれない
								mi=5と考えて
								3,1,4,2,0と移動する時、
								0~2までが増加するような場合
								4,3,2,1,0
								とかになると増加するわけでもないのでさらに厳しくはないだろうか
								最初に4だった場合、0から考えた時に4となるのは何周目か？
									を計算する時
										rを最小値、gを増加量、cを周回数として
										r+cg≡x mod mという式が立つ
											これは互いに素ではない
										(x-r)/g mod m?
								miの半分を超えるかどうか
									
F - Frog Jump
	https://atcoder.jp/contests/abc128/tasks/abc128_f
	0,1,...,n-1に蓮が配置されている
	任意の数A,Bを決め現在地xからx+A,x-Bと交互に移動する
		n-1に着いたらゴールで、すでに移動した場所、または蓮のない場所に止まったらマイナス10^100となる
	得点を最大化するA,Bの組み合わせを求め、その得点を求めよ
		難易度は高めな問題
	性質上A>Bである
		既に通ったところにBで落ちるという場合がダメなわけである
	1<=n<=10^5
		A=4,B=2に設定すると
			4→2
			2→6
			6→4と移動する
		A=4,B=3に設定すると
			4→1
			1→5
			5→2
			2→6と移動する
		最大公約数で移動していくのか？
			いや、A-Bずつ移動する
		AもBも等間隔
			0 5 3 8 6 11 9 14
			0 3 5 6 8 9 11 14
		Aは1ステップ目の位置からA-Bずつ
		Bは0からA-Bずつ
			0 6 4 10 8
		ゴールから考えると
			ステップ1で来る場合
			ステップ2で来る場合
			ステップ3で来る場合
			,......
			に関しては計算可能
				後ろから計算すればよい
			そのステップが可能な場所の限界は決まっている
				例えば5マスあるとき
					ステップ1で処理できるのは
						1ステップ目が
							4,3の時だけ
								これも計算出来そうだ
							3,4と移動するとき
							1*s移動する
							1*sで踏んで上りを踏んでいるか調べる
			上からと下からの累積をまず取る
				調和数になるので、計算量はそこまでいかないはず
					バリバリTLEになる
						累積がいらなかったようだ
					後2パターン残っている
			0 2 3 5
			6
			0 1 -1 -1 1 0
			12
			0 -1 1 1 -1 1 1 -1 1 1 -1 0				

F - Takahashi's Basics in Education and Learning
	https://atcoder.jp/contests/abc129/tasks/abc129_f
	長さLの等差数列s0,s1,s2,...,sL-1
	初項はA,項差はB,si=A+B*i
	数列の各項をつなげて出来る整数を考える
		この整数をMで割った余りはいくつか？
	1<=L,A,B<10^18
	2<=m<=10^9
	等差数列の要素は全て10^18未満
	要素数だけで単純に10^18ということはO(L)は不可
		法則性を見つけて処理させるしかなさそうである
	桁数は保ったまま交差分ずつ加算されていく感じ？
		等差数列の各要素を割った余りでつないでいっても同じになる
			これでO(L)には出来る
				更に工夫が必要である
					各項が交差分ずつ増えていった場合にどのような具合になるのか？
		行列べき乗かダブリングを使用するらしい
			橙レベルになるとそもそも頭に浮かばないことが多いなぁ


D - ロボット
	https://atcoder.jp/contests/abc027/tasks/abc027_d
	最初は0
	mで正または負の好きな方向に距離1だけ移動
	+で幸福度が+x変化
	-で幸福度が-x変化
	最終的に0に戻っている必要がある
		mが偶数個含まれる
			0からマイナスにも動ける
		単純に全パターンを考える時は
			mの個数をtとしたときにmCt
	最後のmが来るときは1,-1のどちらかにいる必要がある
		bitで考えると途中の値の保存が出来ない
		全ての移動に有向辺を貼るのはMLE
			メモ化も100000,100000になるため無理
		ある程度条件で縛る必要がありそう
			同じ形であれば真逆の結果となる
				ということは片側だけ考えれば良さそう
		0に戻った場青そこからの山は線対称とすることが出来る
			つまりその前の山があれば+でも-でも足す事が出来る
				ただし山の位置が確定していないので、
					これも難しそうである。
			実は+とマイナスを中心に考える？
				ある場所の+--が取る値は
					-x
				++--が取る値は0
				+++が取る値は+3x
				と決められる
				それぞれのxを全網羅出来ればクリアできるが
					そうはいかない
				ただしある区間については決められるわけだが
					全部分割されていたりすると計算量を削減する効果はない
				その地点のxはmの数に依存する、
					最初の0と最後の0に戻れる位置内で行う
						基本的には一つ飛ばしである
			絶対にマイナスになることはない
				マイナスになるということはプラスに出来る動きが可能ということである
			あとはプラスにしながら処理すればよい？
				貪欲に移動出来ないのが難しい点である
					ある地点での最大化は全体の最大化に関係するが
						ある地点でxの時に最大化なので、100000*50000となってTLE
			こうなると線形に決めていくしかないように思う
				
C - Triangular Relationship
	https://atcoder.jp/contests/abc108/tasks/arc102_a
	二個までは出来る
		なら3個も出来るのでは？
			n以下でkの倍数を洗い出す
				と思ったが1の倍数の時にTLEする
	あるxを決めた時にkの倍数であれば、他もkの倍数となる
	あるxを決めた時にkの倍数でなければ、他もkの倍数ではない
	例えばk=3の時にx=1と仮定すると
		他は2+knとなるが、それら二つはkの倍数にならない
	k=6の時2だった場合
		他は4+knとなる
			4,10,16,22となり他二つでkの倍数になれない
	あくまでも偶数でk/2の時だけだろう
		
F - Minimum Bounding Box
	https://atcoder.jp/contests/abc130/tasks/abc130_f
	(最大x-最小x)*(最大y-最小y)の最小を求めよ
		全て同じ間隔で移動するため、交差はあっても追い抜くということはない
			複数の点が同じ方向に移動するとき、逆向きに移動する点がその外側にいる時は、最大が大きくなる
				各点が交差する時を拾えばいい？
	R,L,U,Dそれぞれのまとまりを考えた時
	例えばRを考えた時
		Rmax,Rminに対してそれぞれのLがクロスするポイントがある
			その数は最大でも10^5
		秒は関係ないので、移動速度は考えなくてよく、距離がそれだけ移動するということを考える
			クロスするときにどれだけ移動するか？
				調べるのはRLUDそれぞれに対するxmax,ymaxで良いはず
					どれだけの距離を移動するかはそのxmax,ymaxでとれればいいはず
						
F - Colorful Tree
	https://atcoder.jp/contests/abc133/tasks/abc133_f
	木
	色ci,長さdi
	各辺の色は1~n-1
		q個の問いに答える
			j(1<=j<=q)
				色xjの全ての辺の長さがyjに変更されたと仮定して、二項間uj,vj間の距離を求めよ
	２項間なので、ダブリング(LCA)
		頂点1から対象の２頂点までの距離
			色は累積しておく
				累積はどうするか？
					ある頂点まで来た時に、そこにだけ保存しておければ良い気もするが全て保存されていないとだめっぽい
					ある色に対する距離
						mapで保存すると遅くなる？
							なるし、メモリ的にも無理では？
					色と長さの情報がそれぞれ必要となる
						色と長さだけで木を作る？
							深さが分かれば二分探索出来る
					ルートで分岐出来ていないとだめなので却下
						
U - Grouping
	https://atcoder.jp/contests/dp/tasks/dp_u
	bitでそれぞれ1グループとしたときの状態を前計算
	グループ分割をbit反転を使用して処理したと思うが思い出せず
		普通に

D - 漸化式
	https://atcoder.jp/contests/abc009/tasks/abc009_4
	半環とダブリングで処理する
		xorは+
		andは*
			と考え
				k+1,2kの式が出来れば終わり
					k+1はn+kのままである
				an+k=(c1 and a(n+k-1))xor (c2 and a(n+k-2)) xor ....
				an+k+1=(c1 and a(n+k)) xor (c2 and a(n+k-1)) xor ....
				an+k=(c1*a(n+k-1))+(c2*a(n+k-2))+
				=sum(i=1 to k)ci*a(n+k-i)
				=sum(i=1 to k)ci*sum(i=1 to k)a(n+i)
				=sum(i=1 to k)ci=t
				=t*sum(i=1 to k)a(n+k-i)
				a2(n+k)=t*sum(i=1 to k)a2(n+k-i)
				a(2n+2k-2i)
				sum(i=2 to 2k)a
				
F - Permutation Oddness
	https://atcoder.jp/contests/abc134/tasks/abc134_f
	k=sum(i=1to n)abs(i-ai)
		となる組み合わせはいくつあるか？
	1<=n<=50
	0<=k<=n^2
	制約が奇妙ではある
		1,2,3を用意して
		2,1,3とした場合は2
		2,3,1とした場合は4
		3,1,2とした場合も4
		3,2,1とした場合も4
		1,2,3,4を用意して
		4,3,2,1とした場合は8
		2,1,4,3=4
		3,4,1,2=8
		2,3,4,1=6
		奇数になることがなさそう
		2にするときは隣接しているところをひっくり返す以外の方法はない
		4にするときは1つ離れているところをひっくり返すか3つの塊をかぶらないように入れ替えるか
			隣接している2つを2箇所選んでそれぞれひっくり返す
		50!は無理
		自分の数字から離れた分だけ加算されると考える
			範囲で考えられる気がして来た
				がそれは最大値とか最小値を考える時な気もする
					k=n^2なので最大2500
			最初は一つと考える
			次は2つになるその時状態としては2と0が出来る
			次に3つになる、右側に来る場合、真ん中に来る場合、左側に来る場合
				左側に来る場合
					0,2,と4が観測できる
				真ん中に来るとき
					これが新しく、2だったものが一つ距離が離れるので4になる
						後は0のままのパターン
				右側に来るとき
					0,2,4が現れる
				数え方を工夫する必要がある
					n=3であれば
					0が一つ
					2が2つ
					4が3つというカウントになるはずである
						いくつか存在した時、全ての位置が異なる時、その時の値は同じになるか？
							ならない
					どうやってnを増やしていくかが課題
						最初を1として
						上に1増やしたものを付ける、下に1減らした物を付ける
							と考える
							すると1→1,2 または2,1となる
							次に同じように1,2,3のどれかをくっつけるのだが
							その前が2パターン存在しているわけだ
								1,2,3 1,3,2 2,3,1
								2,1,3 3,1,2 3,2,1
								これを考えるとうまくいく気がして来た
									3つめに追加するのが3である場合
										数は増えないはず
									2である場合
										数は割り込む形なので、2増える
									1である場合
										ほかの数も全て増加するはずで自分のところと合わせて4増える
										これをn^2分行えば良さそう
								最初は1のみで0の状態
									次は2,1か1,2の状態
										この時(2-1)*2が0→2に遷移
											　(2-2)*2が0→0に遷移
											最初の2はiで次はjである
												3 4が違う
								1,2,3 1,3,2 2,3,1
								2,1,3 3,1,2 3,2,1 3,1,2の時の4が取れていないのか？
								これはj=2の時に増えないといけない
								違うj=1の時の3,2,1からである
								2→4に遷移するパターン
								1,2
								2,1のパターン
								2,3,1の時に0→4
								3,2,1の時に2→4
								3,1,2の時に2→4
								1,3,2の時は0→2になる
									くっつく数字により補正がされるわけだ
										一番上のパターンは+1+1+2=+4
										2番目のパターンは+1-1+2=+2
										3番目は+1+0+1=+2
										4番目は+0+1+1=+2
											-が入る補正パターンをうまく考えられないか
										下から持ち上げる系の補正を考える
											上側に出ている数、下側に出ている数が管理出来ればいいが
												そこまで管理すると無理っぽい
												2を取るときはそれより小さい数が存在する
													1がそのままの時
														ほかの数は全て持ち上がる
													1が入れ替わっている時
														ほかの数は全て持ち上がる
													あれ？
														これだと2の時(i-2)が全て持ち上がるということである
															これであれば単純にi-2+(i-j)足すだけ
												1を取るときの方が問題だ
													増加量が変わるためである
										こうなると線形で考えるより
											最終形態から考えた方が楽なのでは？

D - 登山家
	https://atcoder.jp/contests/code-festival-2014-qualb/tasks/code_festival_qualB_d
	n個の山小屋が東西一直線に並んでいる
		1からnまで番号が付いている
			標高hiのところに建てられている
				いくつの山小屋を見ることが出来るのか気になる
	1<=n<=10^5
		単純に高さが低いところの山小屋は見えるがそこより高いところが登場するとその先は見えない
			両側から登りになっている分だけ連続で見えるので
				最大を管理しながら処理する？
					違うな
		
C - Swaps
	https://atcoder.jp/contests/nikkei2019-2-qual/tasks/nikkei2019_2_qual_c
	A1,....AnおよびB1,...,Bnが与えられる
		Ai<=Biとなるように出来るか判定してください。
	任意のx,yを選びAx,Ayを入れ替える
		一見好きに入れ替えられるので、Ai<=Biに出来るか
		であるが回数がn-2回までに制限されている
	まずソートした列でAi>Biとなっている箇所があればアウト
	小さい数で考えた時に
	1,2,3となっていて
	2,3,1となっている場合、2回以上必要となるためアウト
	6
		3 1 2 6 3 4
		2 2 8 3 4 3
		1 2 4 6 3 2
		2 2 3 3 4 8
	
D - Shortest Path on a Line
	https://atcoder.jp/contests/nikkei2019-2-qual/tasks/nikkei2019_2_qual_d
	一直線上に点があり1からnまで番号が付いている
		m回の操作によって辺を追加する
		Li,RiおよびCiを用いる
			Li<=s<=t<=Riなる整数の組(s,t)全てに対し、長さCiの辺を追加する
		単純に直線では考えられない
			重い辺から処理していき、上書きしていく
				前から処理をするのでは結局乗り換えをしたときにどっちを取るのかわからない
					辺を張るのが正解な気がする
						前後ろで辺を張る方法を考える
							l→lに貼るのと、r→rに貼る√を考えれば良さそう
								しかしそうなると
								1 10
								2 9
								3 8
								4 7
								のような形で作られた時
									1から先のl頂点全てに貼る
									2から先のl頂点全てに貼る
										といった形で死ぬ
								貼るべき頂点を限定出来ないだろうか
						上の辺を見た時に1→2→9→10のように戻るといったことはあり得ない
							1→10まで10のコスト行けたとして
							2→9がたとえ1のコストだったとしても
								9→10でまたコスト10を掛けてもとに戻る事はないためである
						一番左から自分の範囲が終わるまでに乗り換えるのは一度だけである
							何故なら自分の範囲が終わるまでに2度乗り換えるということは
								最初に乗り換えたコスト掛けなくとも2度目に乗り換えたところに到達可能で、乗り換え可能だからだ
						最初のところから複数本辺が伸びていたら？
						最初の辺が終了した時は？
							結局その先同じ状態になるだろう
		考え方を変えないとだめそう
			コスト0の辺も使ってうまく省略出来ないだろうか
				というか横の辺を貼れば良いのではないだろうか
			最初の頂点から次、横に伸びるところまで辺を貼るのはさっきと同じでは？
				うおおおお、「コスト0の逆辺を貼る」であった
					この発想は弱すぎる。。。毎週やろう


C - 行列のできるドーナツ屋
	https://atcoder.jp/contests/donuts-2015/tasks/donuts_2015_3
	自分は前に並んでいる誰より小さいかが高速に分かれば答えがすぐわかる
		登山家と同じ発想
			と思ったが
				4,3,2,5,6となっている時5からは1,4が見えている状態となる
				自分の一つ前は確実に見えている状態と言える
			    5
			    2 5 3 4 1
				なので一つ前から見えている大きいもの+1が答えとなる
					
C - ロミオとジュリエット
	https://atcoder.jp/contests/arc022/tasks/arc022_3
	任意の2頂点の最大距離を求めたい
		頂点1から出発し、一番遠いところを調べるのと
		二股以上になっている場所をみて遠い二点の和を調べる
			この二つの大きい方
		
E - Who Says a Pun?
	https://atcoder.jp/contests/abc141/tasks/abc141_e
	二つのlengthに対して、重ならないところで処理をする
		普通に出来てたと思っていたが、、、
			頭とけつからそれぞれ部分文字列を作ればいいような気がして来た。
			s[i] == s[j]が同じ時にs[i-1],s[j-1]を見て連続しているようなら処理している
			DPだが、今これが思いつけないのはなかなかである
				この問題はほかにも色々な解法があるようなので、色々試してみよう

C - Folia
	https://atcoder.jp/contests/nomura2020/tasks/nomura2020_c
	計算可能である
		葉と頂点になっている場所を計算すればよい
			頂点数は2x
		0=1
		1=2
		2=4
		n+1の整数列なので、最初の頂点は0
		直接の子の数は2以下なので最後が2^xでていない場合もあり得る
		2x-Adが枝の数
		後ろからやった方がよさそう
			各Adの数の限界は分かる
		0<=Ai<=10^8
		でn<=10^5までなので限界を見ることが出来るのは
			pow(2,63)以下から
			Anから考えて
		前から考えないと矛盾が起こりそう
		
B - Two Contests
	https://atcoder.jp/contests/agc040/tasks/agc040_b
	1からnまでの問題があり、2回のコンテストが行われる
	Li以上Ri以下の参加者は全員正解し、逆にそれ以外の参加者は誰も解けない
		2回のコンテストが行われる
			どちらのコンテストも１問以上出題される必要がある
		どの問題もちょうど1回のコンテストで出題されなくてはいけない
	２回のコンテストの楽しさの和としてありうる最大の値を求めよ
		4
		4 7
		1 4
		5 8
		2 5
	左昇順、右降順に並び替えると
		1 4
		2 5
		4 7
		5 8
	それぞれのコンテストの楽しさの和なので、良い感じにグループ分けしないといけない
		一番大きいものがある場合はそれと、他全部で分ける
	上の例を考えると
		1 4と他に分けると
		4+1=5
		1 4
		2 5とほかに分けると
		3+3=6
		となって一つずつ見ることが出来るが
			証明は出来るか？
		最初に1 4とほかで分けるとき
		グループ1のLiのMaxが1でRiのminが4
		もう片方はLiMax=5,Rimin=5で1となっている
		次に2 5がグループ1に移る
			するとLiMaxが2,Riminは4のままである
			Liの小さい順にグループを変更すると、
			片方のグループはLiが増加し、もう片方のグループは
				LiMaxは変化しないが、Riminが変化していく
			もう片方のグループのLiMaxは常に不変であるため、
				どのようにグループを分けても片方のLiMaxはこの値を取り続ける
					ついでに

C - 億マス計算
	https://atcoder.jp/contests/arc037/tasks/arc037_c
	長さnのaとbの配列のそれぞれを掛け合わせ、昇順に並べる。
		k番目は何か？
	aとbはソートしておく
		この数字は何番目か？の二分探索を行う
			cnt>=kの時に弾く
				
E - Tr/ee
	https://atcoder.jp/contests/arc103/tasks/arc103_c
	構築問題
		各頂点には1,2,...,nの番号が付いている
		各辺には1,2,...,n-1の番号が付いている
		siの文字が1であるとき木からある辺を除く事でサイズiの連結成分が作れる
		siの文字が0であるとき木からどのように辺を除いてもサイズiの連結成分が作れない
	あれば木を構築なければ-1を出力
		s1に関しては0はありえない
		snに関しては1はありえない
			この二つを取っかかりとすると
		s2=1の時、２頂点を結び、片方から1辺だけ伸びている状態
		s2=0の時、2頂点を結び、片方から2本以上の辺が伸びている状態
		1111111,......,0に関しては簡単で、全ての頂点が直線でつながっている状態
	1.いずれかの辺を取り除いてサイズiの連結成分が作れる
		サイズnの連結成分は作れないため
			i=nは0でなければならない
	2.どの辺を取り除いてもサイズiの連結成分が作れない
		anyとallで分けられる
			2.に焦点を当てた方が楽ではないだろうか
				i=1は1でなければならない
					木なので閉路がないから
				i=2の時を考えると
					n頂点で端から2頂点が独立している場所がないことになる
						端の頂点以外は全て3頂点と辺でつながっていなければならない
					単純に考えるとウニグラフ
				i=3の時を考えると
					端の頂点以外は全て4頂点以上とつながっていなくてはならない
					これも単純に考えればウニなのだが。。。
				サンプルも直線かウニとなるものしか書かれていない
					適当な木を作ってみる
						1 2
						2 3
						2 4
						4 5
						のような木である
							11110となってしまう
						1 2
						1 3
						3 4
						3 5
						3 6
							111110となる
								ウニ以外1111,,,,,,,0にならないか？
						頂点数5のウニは
							10010となる
						頂点数7のウニは
							1000010となるだろう
							ウニの辺を2にしてみると
							1100110となる
							1と2を混ぜると
							1100110
						頂点数を8にして4のウニを二つ連結させてみると
							10010010が作れる
		性質の一つとしては
			あるiが作れる場合はn-iも作れるということである
				チェックを行いi!=n-iである場合は-1として良いだろう
				ウニが複数組み合わさっている状態？
				n/2まで見れば良い事もわかる
					紙に書きたいところだが頭の中でやるしかない
				n/2とn-n/2に分けられる時
					大きい方をウニ型にする
					n/2-1とn-n/2+1を作る時は 1.
						n/2のウニ点を一つn-n/2からさらに一つ離して作る
					n/2-1とn-n/2+1を作らない時はそのまま 2.
					n/2-2とn-n/2+2を作る時
						1.の場合、もう一つ離して作る
						2.の場合、二つ離すがn/2-1を作りたくないので
							二つ離して一つn-n/2に近い方に一つ頂点を渡す
								と考えたが、これだとn/2-3になってしまう
									紙に書いて実験できないからわかりにくいが
										片側だけでやろうとするとつくれないのでは？
										両側使う必要があるかも


						
						


						

D - 壊れた電車
	https://atcoder.jp/contests/code-festival-2015-quala/tasks/codefestival_2015_qualA_d
	最短で何分で直せるか
		車両の移動に1分かかる
			1<=m<=10^5
			1<=n<=10^9
	ある整備士の隣どちらかが終点か、他の整備士がいるとき
		その逆方向に向かう
			単純に見るのであれば
				xxxxoxxxxxoxxxxx
				となっている場合
					o1が最初左に向かい
					o2が最初右に行く
					そのあと真ん中に戻っていきo1<x<o2を点検するとき
				4321o9(10)(11)(12)(11)o12345
				かかるので12が最大？
				4321o9(10)(11)321o789(10)(11)
				で11が最大
					外側に向かうのが最善ではなく、最初は短い方に向かうのが最善
				xxxxxxxoxxoxxx
					上のような場合はo1は左に進み、o1は左右の順番に進むのが最善
						それぞれが受け持つ量のバランスを取る
				xxxxxoxxx/xxxoxxxx/xxxxxoxxx
				11
				xxxxxoxxx/xxxoxxxx/xxxxxoxxxo
				11/10/11
				xxxxxo/xxxxxxox/xxxxxxxxo/xxxo
				5/8/8/3
					あるところでどちらかに行けない整備士があらわれると片側に思い切りのばすことが出来るようになる
				xxxxxoxxx/xxxoxxxx/xxxxxoxxxo
				xxxxxox/xxxxxox/xxxxxxxxo/xxxxo
				7/7/8/4
					しかしその量は隣が受け持っていた分を減らすことしかできない
						しかしこれで貪欲出来そうな気がする
				xxxxxxoxxxxxx
				18
					初期状態はこのようにする
				xxxxxxo/xxxxxxo
				6
				xxxxxxox/xxxxxox
				9
					受け持つ量の最大を計算していき、バランスが崩れたらリセット？
						厳しそうな気がする
				回数決めて二分探索
					それで頭から決定していくのが正しそう
						
C - 無駄なものが嫌いな人 
	https://atcoder.jp/contests/arc017/tasks/arc017_3
	大きさxを実現できるn個の荷物の組み合わせの数
		1<=n<=32
		1<=x<=10^9
	なんだかんだ組み合わせ爆発はする
		このnの数は半分全列挙か
			
B - DDPC特別ビュッフェⅡ 
	https://atcoder.jp/contests/discovery2016-final/tasks/discovery_2016_final_b
	まず二分探索が考えられる
		内部は貪欲を行いたい
	時間tを決める
		tまでで取れる物を貪欲に決める
		aの降順にソートし
			ti<tとなっているものを取る
		その時、ギリギリのタイミングで取得する
			setで行けるかと思ったがやりにくい
				ti以下の空き番を探すのであるが。。。
			boolとpriority_queueで処理？
				あふれる
			setで処理？
				setでtiを削除する
					するとti+1が残っている状態になるためlower_bound-1で小さい数が取得出来る
				setの削除処理にかかる時間は？
					定数時間
					O(1)
						境界の処理にやや苦労したがok

No.260 世界のなんとか3
	https://yukicoder.me/problems/no/260
	星4なので難問だが、数え上げの応用なので、冷静に組み立てられれば解けるだろう
		A以上B以下でアホかつ青春しない数①がいくつあるのかを求める
		アホの数...a
		アホかつ青春する数...②
		a-②=①
			aは世界のなんとか2の応用で、上限付き桁DPで世界の何とか2を処理すれば良い
				世界のなんとか2は下の桁から処理していたが、上限付き桁DPはtiteの処理をする必要があるため、ここを考える必要がありそうだ
					最も下の桁で3の倍数ととらえなければならない
				世界のなんとか2で考えても良いレベル
		②は
			3がついて3の倍数ではなくかつ8の倍数、もしくは24の倍数の数を数える
		世界の何とか2は幅を3で持っていたが、こっちは24で持つ必要がありそう？
			24で持った場合、8の倍数は8,16で判定出来る？
				3が出てきた場合は8,16を見て、3が出てこない場合は24=0を見るようにする
		桁DPなのでメモ化再帰で処理した方が楽な気はするが、配るDPなので、普通に上の桁から処理出来ないだろうか？
			遷移先さえ決まれば普通にループでも出来そうなもんだが

		iからi+1に遷移する時
			titeからtite dp[i][tite]→dp[i+1][tite]
			titeからnot tite dp[i][tite]→dp[i+1][not tite]
			への遷移
			dp[i][tite]は その桁の数字jに対してt=0～j-1はnot titeにjはtiteに進むように処理する
			元の数字はkとして(kはaを見る時0~3)、②を見る時0~24))
			dp[i][tite][(k + j) % m]
			3が追加されたかf=0,1
				追加されない場合
				dp[i][tite][0][k] → dp[i+1][tite][0][(k+j)%m]
				初めて追加される場合は
				dp[i][tite][0][k] → dp[i+1][tite][1][(k+j)%m]
				既に追加されている場合
				dp[i][tite][1][k] → dp[i+1][tite][1][(k+j)%m]
				titeの場合も合わせると、遷移は
					dp[i][tite][0][k] → dp[i+1][tite][0][(k+j)%m]
					dp[i][tite][0][k] → dp[i+1][false][0][(k+j)%m]
					dp[i][false][0][k] → dp[i+1][false][0][(k+j)%m]
					dp[i][tite][0][k] → dp[i+1][tite][1][(k+j)%m]
					dp[i][tite][0][k] → dp[i+1][false][1][(k+j)%m]
					dp[i][false][0][k] → dp[i+1][false][1][(k+j)%m]
					dp[i][tite][1][k] → dp[i+1][tite][1][(k+j)%m]
					dp[i][tite][1][k] → dp[i+1][false][1][(k+j)%m]
					dp[i][false][1][k] → dp[i+1][false][1][(k+j)%m]
				あとは全て0のパターンだが、これはtiteでもなく3が付いていないのでdp[n][0][0][0]から1減らす
					組んでみよう

F - Intervals on Tree
	https://atcoder.jp/contests/abc173/tasks/abc173_f
	木構造
	1<=L<=R<=Nに対してf(L,R)を
		Sを番号がL以上R以下の頂点から成る集合とする。
		頂点集合Sと、両端がSに属する辺のみからなるような部分グラフの連結成分の個数をf(L,R)で表す
	と定義する
		sum(L=1,N)sum(R=L,N)f(L,R)を計算する
	連結成分の個数をただ取得するだけでもそこそこ面倒な処理になる
		ある頂点が連結成分に含まれる数を数える？
			では重複が発生する
		頂点を中心に考えるか
		辺を中心に考えるか
		含まれないものを考えるか
			o(n^2)が出来ないのもなかなかつらい制約である
		平準化出来るか？
		巡回で処理するか？
		計算式を分解出来ないか
			sum(L=1,N)sum(R=L,N)f(L,R)
				でsum(R=i,N)f(i,R)を高速に計算出来ないか？
				  iとi+1に関して
				  sum(R=i,N)f(i,R)と
				  sum(R=i+1,N)f(i+1,R)の違いは
					実はそこまで大きくなく、影響範囲を絞れそう？
					その頂点に接続している頂点xたちがx>iである場合、
						分割され、x<iである場合は既に連結成分から外れていると考えられる
					これをうまくまとめられないか
						つながっていたものがつながらなくなるイメージ
						そして一つ連結成分が増えるイメージ
							i<x1<x2でx2に到達した時に1増える
							x1<x2<x3でx3に到達した時に2増える
							x2<y<x3なるyに対して1増える
								これをnまで行うことが出来る
				これで2度同じ頂点は使用しないのでば計算量はo(n+n)=o(n)に抑えられる？
					自分より大きい数だけ使用したいので、ソートしてしまった方がよい
						o(nlogn)となるか

A - Table Tennis Training
	https://atcoder.jp/contests/agc041/tasks/agc041_a
	2n人
	1～n　までのn台の卓
	nペア
	卓xで勝利した選手は次にx-1に行く
	敗北するとx+1に行く
	ある2人の選手
		A,Bで行う
		この二人同士で試合を行えるまでに最小で何回のラウンドが必要か？
	簡単の為A<Bとする
		間隔が偶数である場合は
			(B-A)/2
			1,5だとすると
				2,4→3,3となる
		奇数である場合、1か、nで合わせる必要がある
		両方共同じ方向に動き、1かnに到達した時点で一回とどまる(もう片方は動く)
			そこからは偶数となるため、偶数の場合の計算を行う
			2,3の時は
			1,2、でこの時1を0に置き換えると分かりやすくなる

C - XYZ Triplets
	https://atcoder.jp/contests/aising2020/tasks/aising2020_c
	x^2+y^2+z^2+xy+yz+zx=n
	1<=x,y,z
	1<=n<=10000
	あ、nが最大で10000だった
	x2+y2+xy<=nをまず列挙する
		大した数にならない
	x+yが異なるか。。。
		意外といけちゃうかもしれない
			やっぱり計算量ギャグであった

D - Anything Goes to Zero
	https://atcoder.jp/contests/aising2020/tasks/aising2020_d
	nをpopcount(n)で割った余りに置き換える
		nが0になるまでの操作回数
	xが与えられる
		1<=i<=nを満たす整数iについて
			xの上からi桁目をビット反転した整数をxiとする
	f(x1),f(x2),f(x3),...,f(xn)を求めよ
		1<=n<=2*10^5
	普通にstringで渡されてくる
		しかし、すぐ小さくなる
			あっという間に小さくなる
		厄介なのは、最初の状態から一度計算するところ
			xiに対してpopcountは事前計算o(n)からo(1)で求められる
		初期状態Xに対してf(X+-1)を求める
			xiにbitが立つというのは1<<iに対してbitが立つということ
				これをpopcount(xi)で割った数を
					f(X+-1)にg(1<<i)を足す
						すると第一段階が終了するこれは2のべき乗
							2^imodpを高速で計算するには繰り返し2乗法である
								これで解ける?
									pと2^iが素でなければいけない
										
No.1112 冥界の音楽
	https://yukicoder.me/problems/no/1112
	n音からなる歌を作曲する
	聞こえる音は1,2,...,kしかない
	同時に２つ以上の音が聞こえない
	i番目の音をtiとすると1<=ti<=kでなければならない
	最初の音と最後の音は1でなければならない
	連続する3音の組み合わせに対し
		(Ti,Ti+1,Ti+2)=(Pj,Qj,Rj)となるようなjが存在しなければならない
	上記の制約を満たす曲は何通りあるか？
	1<=k<=6
	1<=m<=k^3
	3<=n<=10^18
	これはダブリングか？行列べき乗か？
	どちらにしろ普通には進めない
		2倍2倍にする組み合わせは作れるだろう
			となるとダブリングか
	0から考え直し
		端と端で考えるとまたいだ時に存在出来ない状態が出来上がる
			これを解消するには一つ中の値まで把握しておかなければならない
		単純に考えると
			左端2個、右端2個をdpテーブルで持っておいて
				6^5重ループで処理させる

E - Camel Train
	https://atcoder.jp/contests/aising2020/tasks/aising2020_e
	パッと思いつくのは両側から処理するか
	各iから処理していく
	それぞれ貪欲で処理する事が考えられるが、反例がないか考える必要がある
		両側から処理するのは反例がある
			両側から貪欲に処理するのに反例があるのであれば、各iから処理するのも反例がありそう
				1 100 1
				2 ? ?
			と思ったがこの二つだけではなりたたない
				1 50 100
				2 70 70
				だと1が2の位置にいって2はそのままである
			キーとなるのは場所の入れ替えなのでは？
		単純に考えれば
			後ろから前に行く場合、自分の数字が大きくなる事はなく
				動きたいのは前から後ろに行きたいときである
					1 100 90
					1 80 30
				となっている時
					1 2の順だと130
					2 1の順だと170となる
			というかki!=iであることを忘れていた
				ある2点の入れ替えだけではないだろう
					lとrの差は重要、というか貪欲はこの値をキーとして処理するはず
					マイナスの値はなし
			貪欲に見て、自分の置きたい方に置けなくなった場合、
				配置しないでいったんキープする（置いてしまうと別の物が置けなくなるため）
					というか配置しないで少ない方の値を足す？
				差の大きさでソートする
					さて、このやり方で反例が出るか？
						101 1
					あ、というか両方の値から小さい方を引いた数が加算される数と考えると
						もう少しわかりやすくなる
					貪欲ではないというのは
						一つの大きな数を置かないで、この小さな数二つを配置した方が大きくなる
							ような考え方をしたときにその例があるときである
								マイナスがあるときは確かにあり得る
							しかし、これはマイナスがないのだ、組み立ててみよう
					1 5 10
					2 15 5
					このパターンで合わない
						位置を貪欲に取ることが難しそうだ
							kiがmaxの場合は外してしまってもよいというのはある
								しかし、これが3の時に上手く機能しないのではないだろうか？
									1 5 10
									2 15 5
									2 15 20
										これはまぁ行ける
									1 5 10
									2 15 5
									2 15 20
										この時45が取れないのでやはりダメ
							位置中心に考える方がよいか？
								1に配置するのは？
									上の場合は2しかありえない
								2に配置するのは?
									1を配置したい
								3は残りとして処理される	
							もちろん、このやりかたも微妙
								両側からはやる必要がないと言った点では一つ楽になっていはする
									結局これも貪欲になるのでダメだろう
			自由に配置出来るような考え方は出来ないだろうか？
				例えば上の
					1 5 10
					2 15 5
				であれば
					2を置いた次に1を置くわけだが
						1は2より右側に置きたいのである
					今見つけたポイントは
						右に置きたいか左に置きたいかのバランス
			左から考えてiに到達したとき
				kiとなるラクダの集合sが|s|>iである場合
					s-i匹は総和にプラスされない=どこにいてもよい
				ここで小さい方から省いていくと求められる
					右からも同じ事を行い
						最後に集合に残っていたラクダ分をaddする
							
E - Count Median
	https://atcoder.jp/contests/abc169/tasks/abc169_e
	n個の値x1,x2,...,xnがある
	それぞれの値はai<=xi<=biである
		中央値として取れる値はいくつあるか？
	とれる幅の最大と最小によってその真ん中になっていると感じる
		データの数が偶数個だと、真ん中二つの値の平均を取る
		データの数が奇数個だと、真ん中の値を取る
	奇数と偶数で分けた方が良さそう
		奇数の場合、真ん中になる数がどこまでの範囲を取るかで考えられる
			10 100
			50 150
			25 75
			これは25~75でOKだろう
			10 100 
			20 30
			40 50
			60 70
			80 90
			この時は40~70までを取ることが出来る
			10 100 
			20 110
			40 50
			60 70
			80 90
			この時は40~90までを取ることが出来る
				単純に見るとaiでソートした真ん中とbiでソートした真ん中で見れば良いと思われる
			要素が被っていない場合はどうなるか？
				やはり同じ考えで良いだろう
		偶数の方が厄介そう
			二要素で考える必要があるので、範囲を考えなければならない
			1 2
			3 4
			となった時に
				この場合は1,3と2,4で考えるとすると
					1~2から3~4が範囲となるわけだ
						この時2,5/2,3が取れる
							おや？
								中央値は1,3の真ん中～2,4の真ん中であるように見える
				1 5
				3 4
				の時は？
				1,3と4,5の組み合わせ
				2~4.5まで取れるように見える
					2倍すると楽そう
				2,6と8,10
					4～9まで、つまり6個
				2~4.5も
					2 ,2.5,3 ,3.5 ,4 ,4.5の6個


				
				


			

	




									
				
		


		
	
				
				

				


						
								
						





	


					


