A - Xor Battle
	https://atcoder.jp/contests/agc045/tasks/agc045_a
	二人の人
		0と1の番号がついている。
		0で初期化された変数xがある。
		nラウンドからなるgameを行う
		人siがいずれかの操作をする
			xをx^aiで置き換える
			何もしない
		人0の目標は最終的にx=0にする事
		人1の目標は最終的にx!=0にすること
		二人が最適に行動するとき、最終的にxが0になるかどうかを判定する
	T個のテストケース
		1<=t<=100
		1<=n<=200
		1<=ai<=10^18
		sは0と1のみからなる長さnの文字列
	siの行動なので交互ではない
	交互ではないがnimに帰着出来る？
		難しそう
	それぞれのbitについて考えれば良さそう
		1はどこかのbitを立てられれば良い
		最初は0からスタート
			あるbitについて
				s=10で並んでいるときに
				両プレイヤー共に対象のbitを立てられる場合
					1が立てたら、0がおろす
					1が立てなければ、0はそのまま
					と行ったように1は立っていなければ立てる
					立っていたらそのままにする、ぐらいしかやりようがないのでは？
		1111
		1010
			あるbitに対しての最適は他のbitに対して最適ではないということである
				1 3となっている時に
				10である場合、3の時にbitを下げようとすると2が立つ
					bit毎に考えられない感じである
				1 3 1
				100である場合は最後に下げればよいためok
				ただ、bit毎に考えるのはあっている気はする
				0は自分の上げたbitを下げられればok
					後ろから考えた時
					最後が1だった場合は1である
				1になるパターンは、1の時に立てたbitを下げる手立てがない場合
				1の時に立てたbitを0が下げようとして他のbitが立ち、そのまま戻らない場合である
					逆に考えると
						1が処理するあらゆるパターンに対して0は対処できないといけない
							ある地点でこのパターンのbitが立っている時、0は対処できるか？
								でdp出来る？
							ある地点でこのパターンのbitにさせないという最適もあるためだめ
				gamedpで行けるのか？
					0は小さくするというわけではなく0にするというテーマのためやりにくい
				あとmemo化出来ない
				nimでもない
		最後が0だった場合
			x=anもしくはx=0だった場合は0に出来、それ以外は1
		最後の2つが0だった場合
			x=an^an-1もしくはx=0もしくはx=an,x=an-1だった場合は0
	各bitに狙いを絞る？
		1はあるところでこのbitを立てない事により0が立てる事になるというパターンもある

B - 01 Unbalanced
	https://atcoder.jp/contests/agc045/tasks/agc045_b
	文字列s
		'0','1','?'のいずれか
	sに含まれる全ての?を0か1に変えて文字列s'を作る事を考える
		s'のアンバランス度=max{s'のl文字目からr文字目までに含まれる0の個数と1の個数の差の絶対値:1<=l<=r<=|s|}
	s'のアンバランス度としてありうる最小の値を求める
		個数の差の絶対値なので0??の場合は010が最小となる
	1<=|s|<=1^6
		と結構大きい
	1として進んだか、0として進んだかで最小値が変わるわけである
	偶然ジェネレータに近い気がする
		あれと似ている
	あれはk以内のパターンがいくつできるか？
	だったがこれは最小値は何か？という計算をすればよい
		アンバランス度はiが1進んだときに+1か-1しかされない
		あれか、bit管理のやつか
			なんだっけ
				bitsetだ
		しかし、これは途中の状態も考慮する必要がある
			途中から途中で考えてもmaxがでかければそれで終わりである
				連続している0もしくは1の数？
		入力例3が4なのだが
			1?11?111???の部分はどうしても4になる
				1?110111で4である
			10110111で4である
			最初の入力例は
			0??であり
			これは010とするのが正解
			001だと2になるため
			0?0であっても1
			1?11??111???であるとき
			101100111000、これは3
			1234
			101210123210
			10110011100001
			10121012321010
			だたしかしこれは4
			10110011100001
			1012101232100(ここで4という形にするしかない)0
			10110011100011
			10121012321012となりこれは3
			最大値を管理しながら処理すれば行ける？
			100100100100100
		now 100100100100100
		r   112223334445556
		rは取れるのだが、正直dpしないとダメな気はする
			10?10?10?10?10?
		now 101210101210101
		r   111222222222222
		しかしこれだと貪欲なのでパターンによってはダメだろう
			10?????11111111
		now 101010123456789
		r   111111123456789
			10?????11111111
		now 100100012345678
		r   112223444445678
		ということで最大値を増やさない方向に進むというのは間違っているわけだ
		まず連続している1もしくは0の最大値がとりあえずの最小値で
			そこからの増加をいくつまで減らせるかを考える必要がある
		これは陣取りではないだろうか？
			ん？ある場所で0に進むか1に進むかで最小値を拾うようにすればいいのか？
			10?????11111111
		now 101010123456789
		r   111111123456789
		now 100101012345678
		r   112222222345678
		3の地点で1に進む場合は最大値が1である
		0に進む場合は最大値が2である
			10?1
			4つめを取る場合は
				3つめ最大値の小さい方から取りたい
					これnowの位置で変わるからやっぱりだめだ
					nowの位置によってそのあとの最大値が変化するのである
		というかdpは無理
			貪欲で工夫するのが正解だろう
			00000?1111111なるとき
			この場合は0にするのが正解
			00000?1111011なるとき
			1するのが正解
				0?1の時、どっちにするもの正解だが
				0?10000000000
				となっている場合は1にするのが正解
					10?????11111111
					10,,,,,12345678
						と仮置きする
					111111111??????01
					123456789,,,,,,01
						と仮置きする
						,,,,,,は
			数字が既に入っているところは、絶対値の差が最大いくつになるか分かる
				00111010000101のように数字が入っていれば
				12223333334444のような具合である
				これはnowとmaxを管理すれば全然取れる
				??????????????
				基本的には交互に入れていけば最適が取れる？
				111111????????000000000
				123456        123456789
				バッファを消していく考え方
				111111????????
				12345654343212
				間にある?の数が偶数個のため取れる数は最後の6から偶数個の範囲
				111111????????000000000
				12345666666666
				12345654343212101234567
				1234566666666666789,,,,,
					2入りだと最後が7になる
				12345654343234321000000
				123456666666666666789,,
					4入りだと最後の最大が11になる
					このように?の数で調節出来る
						最後の位置と?の数で計算出来れば行ける？
					マイナス方向に最大値9増えるわけだが
				最初の位置は0から始まり?の数も0個











		

			

									


					


						
					

