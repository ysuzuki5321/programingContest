G - グリッド金移動
	2次元グリッド
	n個の障害物
	マスxi,yiにある
	一回の移動で
		(x+1,y+1)
		(x,y+1)
		(x-1,y+1)
		(x+1,y)
		(x-1,y)
		(x,y-1)に移動出来る
	(0,0)
		から移動して(X,Y)
			にたどりつくための最短経路は？
				グリッドグラフを用意
					500,500で用意して
					250,250がスタートで
					250+x,250+yがゴール
					あとはbfs

H - ハードル走
	0がスタートLがゴール
	i番目のハードルはxiにある
	距離1を進む、
	距離0.5を走って進み、ジャンプして距離1を進み、また0.5進む
	距離0.5を走って進み、ジャンプして距離3を進み、また0.5進む
	走っているときはt1秒
	ジャンプ中はt2秒
	ジャンプ中でないときにハードルがあるときはt3秒かかる
	t1,t2,t3は全て偶数
	Lを通るまでにかかる秒数の最小値は？
		DP
			あるiに到達出来る数パターン
				i-1に関してはt1で
					i-1がハードルならばt3
				i-2に関してはt1+t2
					i-2がハードルならばt3/2
					i-1がハードルならばt3/2
				i-4に関してt1+t2
					i-4がハードルならばt3/2
					t-1がハードルならばt3/2


I - 行列操作
	n*n行列
		それぞれのクエリに関して操作する
		1,a,b行を交換する
		2,a,b列を交換する
		3,行列を転覆するi,j→j,iに置き換える
		4,a,bを出力する
	nが大きいのでテーブルは作れない
	テーブルの要素数は
		n*n
			番号は0~n*n-1まで振られている
		大きい方から小さい方への移動、小さい方から大きい方への移動
			(a-b)=t
			1の場合は
				g(a,j)→g(a-(t*n),j)→xi-(t*n)
				g(b,j)→g(b+(t*n),j)→xj+(t*n)
			2の場合は
				g(i,a)→g(i,a-t)→xi-t
				g(i,b)→g(i,b+t)→xj+t
			で移動が行われる
			3の場合は
			(i-j)=tとして
				g(i,j)→g(i-t,j+t)
				転覆の計算式は
					xi-(t*n)+t
		である
			4の座標から逆算することも考えられる
				全ての座標を押さえて処理するとなると
				4が5万来た後に、1,2,3がグルグル行われて5万処理されるといったことになるため、
					TLEとなる
				関係のある場所を計算出来れば行けそうだが。。。
					実は先頭から追って行ける？
				3の処理がやっかいではないか？
					計算式は出来たが、あくまでも初期状態と言えそう
						飛ばそう

J - 回転寿司
	n人の子供
	1~nの番号が付いている
		m個の寿司
		i番目のすしのおいしさはai
		まだ寿司を食べていない
		今までに食べたどの寿司よりもおいしさが大きい
	それぞれのすしについて、何番の子供が食べるかを求める
		300000でTLEを誘っている
			前から強制的に処理される
				逆にして最長増加列？
				2 5
				5 3 2 4 8
				-5 -3 -2 -4 -8
				-5
				-5 -3
				-5 -3 -2
				-5 -4 -2
				-8となるため
				-5 -5 -5 
				-5
				-5 -5
				-5 -5 -5 となるような組み方をする必要がある
					
K - コンテナの移動
	1~nの番号がついたn個の机と1=nの番号がついたコンテナ
		机の上には複数のコンテナを積み上げられる
			コンテナiは机iの上に置かれている
		q個のクエリ
			順番に処理をする
		机fiにあるコンテナxiとその上に積み上げられたコンテナたちを
		、机tiに順番を変えずに移動させる
		この時、机tiにすでにある場合はさらに積み上げるように積む
	2<=n=2*100000
	1<=q<=2*100000
		最終的に各コンテナがどこにあるのか出力する
			分離と切断が簡単に出来るデータ構造があれば楽だが
		ないのでアルゴリズムで処理するしかない
			有向グラフが見える
			グループ化したあと分離するのも無理
				複数個が変化するという状況になるわけである
		しかも連続していないので、まとめて更新も難しい
		有向グラフは見えない
			クエリを逆順にすると最終状態が
			1,2,3,4,5,6,7,8,9,.....,nの状態になる
			1 3 2は
			3から1に2を戻す
			ここで3に2があったことが確定している
			3 1 3は
			1から3に3を戻す
			しかし2がその上にあるかどうかは不明
		どれの上にいるかが分かっていればいいのか？
			1→2で1は2の上にいる、2の一番上は1
			2→3 2で2は3の上にいる、3の一番上は1
			3→1 3で1の一番下は3,一番上は1
			1→3 2で2が分離して3の一番上は1,一番下は2
			自分の親だけ分かっていれば良い？

L - スーパーマーケット
	手前からai列までで一番数字が大きいものから消えていく
	消えたあとは前に詰められる
		ai列目まで見るのもなかなか難しいが
		詰められるのも難しい
	取られた時の状態の変化はあまり大きくない？
	1<=ai<=2である
		2の場合と1の場合で適切に管理出来れば行けそう
		pqueueで行きたい
		1でとられた場合、1のpqのtopを取り除く
		1のpq,2のpqにそれぞれ対象の列の先頭を足す
			

				
							
					


	