E - Two Currencies
	https://atcoder.jp/contests/abc164/tasks/abc164_e
	1~nまでのn個の都市
		m本の鉄道
	10^100枚の金貨、銀貨をS枚
		都市1に居る
	辺はuiとviを双方向に結んでいる
		銀貨Ai枚、移動にかかる時間はBi分
	両替所があり金貨1枚を銀貨Ci枚と交換できる
		交換には金貨1枚あたりDi分かかる
	t=2,...,Nについて都市1からtへの移動にかかる最小の時間を求めよ
	頂点数から考えるとワーシャルフロイドっぽい
		10^100で各運賃の最大は10^9、辺の数は最大50なので
			金貨は好きに使えると考えられる
				移動にかかる時間ごとに所持銀貨を考えられれば良いが
				10^9なので無理レベルだろう
			ある頂点への最短が次の頂点への最短ではない
				グラフを二つに割れないか？
					金貨を交換する場所を限定する
						銀貨が足りている場合はただの最短距離で出せる
						結局足りていない場合についてのみ考えればよい
							ワーシャルフロイドで全ての点についての最短距離を求めておく
								ある頂点まで行ってから次の頂点までいくのを考える
								1から出発し、対象の頂点までの銀貨が足りない場合、
								すでに行ける場所をめぐり、どこで交換するのが一番時間が短いかを確かめなければならない
									ある頂点に到達するときに使われている頂点を保持する
										これでdfs?ダイクストラ？
											なんとなくdfsの方がよさそうだが
												bsfじゃないと行けなさそう
													訪問済みじゃないとこに行くのが最短という可能性も考えられる
							行けない頂点が複数個候補に挙がる場合、
								どこに行くのが一番コストが安いかを考える
									いったんいけるところは全て訪問する
									普通のbfsと違って、弾かないのかもしれない
									保持しているものと比較して
										時間が多く、銀貨が少ない場合ははじく
										時間が多く、銀貨が多い場合は弾かない
										時間が少ない場合は弾かない
									違う、この路線は泥沼である
										もっと違う考え方が出来るはず
											全部訪問済みになるまで繰り返すか？
										ワーシャルフロイドをn回繰り返す？
											行けるところは行ける
						Ai<=50であった
							

F - I hate Matrix Construction
	https://atcoder.jp/contests/abc164/tasks/abc164_f
	n掛けるn行列を作る
	si=0の時、i行目のビット毎の論理積はUi
	si=1の時論理和はUi
	ti=0の時、i列の論理積はVi
	ti=1の時、i列目の論理和はVi
		ビット毎に考えられるか？
			論理積の方が埋めるのは簡単である
				ある行、列に関して、そのbitを全て立てるように作る
				和がめんどくさい気がする
					論理積で確定で建てる
					交差している行列を考えた時
					論理和で立っておらず、論理積で立っている場合はNG
					論理和で立っていて、論理積で立っていないが、全て立ってしまう場合NG


										
													
					